# HT-022.1.1: Agency Component Architecture Design

**Task:** HT-022.1.1 - Agency Component Architecture Design
**Phase:** Phase 1 - Agency Component Architecture & Client Theming System
**Status:** Complete
**Date:** September 14, 2025
**Duration:** 1 hour
**Priority:** Critical

## Executive Summary

This document presents the Agency Component Architecture Design for rapid custom micro-app development and client white-labeling. The architecture builds upon the existing HT-021 foundation to create a simplified, agency-focused component system that enables ≤7-day micro-app delivery with ≤2-hour client customization.

## 1. Agency Component Architecture Overview

### 1.1 Architecture Principles

```typescript
interface AgencyComponentPrinciples {
  simplicity: 'Minimize complexity for rapid development';
  customization: 'Enable quick client theming and branding';
  composition: 'Support flexible component composition';
  reusability: 'Maximize component reuse across micro-apps';
  performance: 'Maintain sub-200ms render targets';
  accessibility: 'WCAG 2.1 AA compliance by default';
}
```

### 1.2 Simplified Atomic Design for Agencies

```typescript
// Agency-focused atomic design hierarchy
interface AgencyAtomicDesign {
  // Layer 1: Essential Atoms (10-15 components)
  atoms: {
    inputs: ['Button', 'Input', 'Checkbox', 'Select', 'TextArea'];
    display: ['Text', 'Heading', 'Badge', 'Avatar', 'Icon'];
    feedback: ['Spinner', 'Alert', 'Toast', 'Progress'];
  };

  // Layer 2: Functional Molecules (8-12 components)
  molecules: {
    forms: ['FormField', 'SearchBox', 'FilterGroup'];
    navigation: ['Breadcrumb', 'TabGroup', 'Pagination'];
    display: ['Card', 'Modal', 'Dropdown', 'Tooltip'];
  };

  // Layer 3: Business Organisms (5-8 components)
  organisms: {
    layout: ['Header', 'Sidebar', 'Footer'];
    data: ['DataTable', 'Dashboard'];
    forms: ['ContactForm', 'SettingsPanel'];
  };

  // Layer 4: Page Templates (3-5 templates)
  templates: {
    layouts: ['AppLayout', 'LandingLayout', 'DashboardLayout'];
    pages: ['HomePage', 'ContactPage'];
  };
}
```

## 2. Simple Component Patterns

### 2.1 Agency Component Interface Standard

```typescript
interface AgencyComponentProps {
  // Core properties
  id?: string;
  className?: string;
  'data-testid'?: string;

  // Agency-specific properties
  brandVariant?: 'client' | 'default';
  customTheme?: ClientTheme;
  priority?: 'high' | 'normal' | 'low';

  // Simplified variants
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost';
  size?: 'sm' | 'md' | 'lg';

  // State management
  loading?: boolean;
  disabled?: boolean;
  error?: string;

  // Accessibility (simplified)
  'aria-label'?: string;
  role?: string;

  // Event handling
  onClick?: () => void;
  onChange?: (value: any) => void;

  // Composition
  children?: React.ReactNode;
}

// Simplified client theme interface
interface ClientTheme {
  colors: {
    primary: string;
    secondary: string;
    accent?: string;
    text: string;
    background: string;
  };
  fonts: {
    primary: string;
    secondary?: string;
  };
  logo: {
    src: string;
    alt: string;
    width: number;
    height: number;
  };
}
```

### 2.2 Component Composition Patterns

#### Pattern 1: Simple Compound Components
```typescript
// Card compound component for agency use
const AgencyCard = {
  Root: ({ children, customTheme, ...props }: AgencyComponentProps) => (
    <div
      className={cn('agency-card', applyClientTheme(customTheme))}
      {...props}
    >
      {children}
    </div>
  ),

  Header: ({ children, ...props }: AgencyComponentProps) => (
    <div className="agency-card-header" {...props}>{children}</div>
  ),

  Content: ({ children, ...props }: AgencyComponentProps) => (
    <div className="agency-card-content" {...props}>{children}</div>
  ),

  Footer: ({ children, ...props }: AgencyComponentProps) => (
    <div className="agency-card-footer" {...props}>{children}</div>
  )
};

// Usage pattern for agencies
<AgencyCard.Root customTheme={clientTheme}>
  <AgencyCard.Header>
    <Heading variant="h3">Client Dashboard</Heading>
  </AgencyCard.Header>
  <AgencyCard.Content>
    <Text>Dashboard content with client branding</Text>
  </AgencyCard.Content>
</AgencyCard.Root>
```

#### Pattern 2: Themeable Component Factory
```typescript
// Factory for creating client-themed components
function createClientThemedComponent<T extends AgencyComponentProps>(
  BaseComponent: React.ComponentType<T>,
  defaultTheme: ClientTheme
) {
  return function ThemedComponent(props: T & { clientId?: string }) {
    const clientTheme = useClientTheme(props.clientId) || defaultTheme;

    return (
      <BaseComponent
        {...props}
        customTheme={clientTheme}
        className={cn(props.className, `client-${props.clientId}`)}
      />
    );
  };
}

// Usage for agency projects
const ClientButton = createClientThemedComponent(Button, defaultClientTheme);
const ClientCard = createClientThemedComponent(AgencyCard.Root, defaultClientTheme);
```

## 3. Basic Customization Interface

### 3.1 Client Theme Configuration

```typescript
interface ClientThemeConfig {
  // Basic brand colors (required)
  brand: {
    primary: string;
    secondary: string;
    text: string;
    background: string;
  };

  // Optional enhancements
  enhancements?: {
    accent?: string;
    gradient?: string;
    shadow?: string;
  };

  // Typography (simplified)
  typography: {
    fontFamily: string;
    fontSize: {
      sm: string;
      base: string;
      lg: string;
      xl: string;
    };
  };

  // Logo configuration
  logo: {
    src: string;
    alt: string;
    width: number;
    height: number;
    position: 'left' | 'center' | 'right';
  };

  // Layout preferences
  layout?: {
    borderRadius: 'none' | 'sm' | 'md' | 'lg';
    spacing: 'tight' | 'normal' | 'loose';
    shadows: boolean;
  };
}

// Theme validation for agencies
function validateClientTheme(theme: ClientThemeConfig): ValidationResult {
  const errors: string[] = [];

  // Color contrast validation
  if (!hasGoodContrast(theme.brand.text, theme.brand.background)) {
    errors.push('Insufficient color contrast for accessibility');
  }

  // Required fields
  if (!theme.brand.primary || !theme.brand.secondary) {
    errors.push('Primary and secondary colors are required');
  }

  // Logo validation
  if (!theme.logo.src || !theme.logo.alt) {
    errors.push('Logo source and alt text are required');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}
```

### 3.2 Simple Theme Application System

```typescript
// Theme application utility for components
function applyClientTheme(theme?: ClientTheme): string {
  if (!theme) return '';

  const cssVariables = {
    '--client-primary': theme.colors.primary,
    '--client-secondary': theme.colors.secondary,
    '--client-text': theme.colors.text,
    '--client-background': theme.colors.background,
    '--client-font': theme.fonts.primary,
  };

  // Generate CSS custom properties
  const styleString = Object.entries(cssVariables)
    .map(([key, value]) => `${key}: ${value}`)
    .join('; ');

  return `client-themed`;
}

// CSS-in-JS theme integration
const clientThemeStyles = {
  '.client-themed': {
    '--primary': 'var(--client-primary)',
    '--secondary': 'var(--client-secondary)',
    '--text': 'var(--client-text)',
    '--background': 'var(--client-background)',
    'font-family': 'var(--client-font)',
  },

  '.client-themed .agency-button': {
    backgroundColor: 'var(--primary)',
    color: 'var(--text)',
    fontFamily: 'var(--client-font)',
  },

  '.client-themed .agency-card': {
    backgroundColor: 'var(--background)',
    color: 'var(--text)',
    borderColor: 'var(--secondary)',
  }
};
```

## 4. Component Composition Patterns

### 4.1 Micro-App Layout Pattern

```typescript
interface MicroAppLayoutProps {
  clientTheme: ClientTheme;
  navigation?: NavigationItem[];
  header?: React.ReactNode;
  sidebar?: React.ReactNode;
  footer?: React.ReactNode;
  children: React.ReactNode;
}

// Standard micro-app layout for agencies
function MicroAppLayout({
  clientTheme,
  navigation,
  header,
  sidebar,
  footer,
  children
}: MicroAppLayoutProps) {
  return (
    <div className={cn('micro-app-layout', applyClientTheme(clientTheme))}>
      {/* Client-branded header */}
      <header className="micro-app-header">
        <ClientLogo theme={clientTheme} />
        {header}
        {navigation && <Navigation items={navigation} theme={clientTheme} />}
      </header>

      {/* Main content area */}
      <main className="micro-app-main">
        {sidebar && (
          <aside className="micro-app-sidebar">
            {sidebar}
          </aside>
        )}
        <section className="micro-app-content">
          {children}
        </section>
      </main>

      {/* Client-branded footer */}
      {footer && (
        <footer className="micro-app-footer">
          {footer}
        </footer>
      )}
    </div>
  );
}
```

### 4.2 Rapid Page Composition Pattern

```typescript
// Page builder for rapid micro-app development
interface PageBuilderProps {
  clientTheme: ClientTheme;
  pageConfig: PageConfiguration;
  data?: any;
}

interface PageConfiguration {
  layout: 'landing' | 'dashboard' | 'form' | 'content';
  sections: PageSection[];
  navigation?: NavigationConfig;
  branding?: BrandingConfig;
}

function PageBuilder({ clientTheme, pageConfig, data }: PageBuilderProps) {
  const PageTemplate = getPageTemplate(pageConfig.layout);

  return (
    <PageTemplate theme={clientTheme}>
      {pageConfig.sections.map((section, index) => {
        const SectionComponent = getSectionComponent(section.type);
        return (
          <SectionComponent
            key={index}
            theme={clientTheme}
            config={section.config}
            data={data?.[section.dataKey]}
          />
        );
      })}
    </PageTemplate>
  );
}

// Pre-built section components for agencies
const AgencySections = {
  Hero: ({ theme, config, data }: SectionProps) => (
    <section className={cn('hero-section', applyClientTheme(theme))}>
      <ClientLogo theme={theme} />
      <Heading variant="h1">{config.title || data?.title}</Heading>
      <Text>{config.description || data?.description}</Text>
      <Button variant="primary">{config.ctaText || 'Get Started'}</Button>
    </section>
  ),

  Features: ({ theme, config, data }: SectionProps) => (
    <section className={cn('features-section', applyClientTheme(theme))}>
      <div className="features-grid">
        {(data?.features || config.features)?.map((feature: any) => (
          <AgencyCard.Root key={feature.id} customTheme={theme}>
            <AgencyCard.Content>
              <Icon name={feature.icon} />
              <Heading variant="h3">{feature.title}</Heading>
              <Text>{feature.description}</Text>
            </AgencyCard.Content>
          </AgencyCard.Root>
        ))}
      </div>
    </section>
  ),

  Contact: ({ theme, config, data }: SectionProps) => (
    <section className={cn('contact-section', applyClientTheme(theme))}>
      <ContactForm theme={theme} config={config} />
    </section>
  )
};
```

## 5. Basic Customization System Architecture

### 5.1 Client Configuration Management

```typescript
interface ClientConfigManager {
  // Get client configuration
  getConfig(clientId: string): Promise<ClientThemeConfig>;

  // Update client configuration
  updateConfig(clientId: string, config: Partial<ClientThemeConfig>): Promise<void>;

  // Validate configuration
  validateConfig(config: ClientThemeConfig): ValidationResult;

  // Generate CSS for client
  generateClientCSS(clientId: string): Promise<string>;

  // Preview client theme
  previewTheme(config: ClientThemeConfig): string;
}

// Implementation for agency use
class SimpleClientConfigManager implements ClientConfigManager {
  private configs = new Map<string, ClientThemeConfig>();

  async getConfig(clientId: string): Promise<ClientThemeConfig> {
    return this.configs.get(clientId) || getDefaultClientConfig();
  }

  async updateConfig(clientId: string, config: Partial<ClientThemeConfig>): Promise<void> {
    const existingConfig = await this.getConfig(clientId);
    const newConfig = { ...existingConfig, ...config };

    const validation = this.validateConfig(newConfig);
    if (!validation.isValid) {
      throw new Error(`Invalid configuration: ${validation.errors.join(', ')}`);
    }

    this.configs.set(clientId, newConfig);

    // Generate and cache client CSS
    await this.generateClientCSS(clientId);
  }

  validateConfig(config: ClientThemeConfig): ValidationResult {
    return validateClientTheme(config);
  }

  async generateClientCSS(clientId: string): Promise<string> {
    const config = await this.getConfig(clientId);
    return generateClientThemedCSS(config);
  }

  previewTheme(config: ClientThemeConfig): string {
    return generateClientThemedCSS(config);
  }
}
```

### 5.2 Theme Switching System

```typescript
// Context for client theme management
const ClientThemeContext = createContext<{
  currentTheme: ClientTheme | null;
  switchTheme: (clientId: string) => void;
  previewTheme: (config: ClientThemeConfig) => void;
  clearPreview: () => void;
}>({
  currentTheme: null,
  switchTheme: () => {},
  previewTheme: () => {},
  clearPreview: () => {}
});

// Provider for client theme context
export function ClientThemeProvider({ children }: { children: React.ReactNode }) {
  const [currentTheme, setCurrentTheme] = useState<ClientTheme | null>(null);
  const [previewConfig, setPreviewConfig] = useState<ClientThemeConfig | null>(null);

  const switchTheme = useCallback(async (clientId: string) => {
    const config = await configManager.getConfig(clientId);
    setCurrentTheme(configToTheme(config));
    setPreviewConfig(null);
  }, []);

  const previewTheme = useCallback((config: ClientThemeConfig) => {
    setPreviewConfig(config);
    setCurrentTheme(configToTheme(config));
  }, []);

  const clearPreview = useCallback(() => {
    setPreviewConfig(null);
    // Revert to original theme
  }, []);

  // Apply theme to document root
  useEffect(() => {
    if (currentTheme) {
      applyThemeToDocument(currentTheme);
    }
  }, [currentTheme]);

  return (
    <ClientThemeContext.Provider value={{
      currentTheme,
      switchTheme,
      previewTheme,
      clearPreview
    }}>
      {children}
    </ClientThemeContext.Provider>
  );
}
```

## 6. Simple White-Labeling Workflow

### 6.1 Agency White-Label Process

```typescript
interface WhiteLabelWorkflow {
  // Step 1: Initialize client project
  initializeProject(clientConfig: {
    name: string;
    domain: string;
    contactEmail: string;
  }): Promise<ProjectInit>;

  // Step 2: Configure branding
  configureBranding(projectId: string, branding: {
    theme: ClientThemeConfig;
    logo: LogoConfig;
    content: ContentConfig;
  }): Promise<void>;

  // Step 3: Customize components
  customizeComponents(projectId: string, customizations: {
    components: ComponentCustomization[];
    layouts: LayoutCustomization[];
  }): Promise<void>;

  // Step 4: Deploy micro-app
  deployMicroApp(projectId: string, deployment: {
    domain: string;
    environment: 'staging' | 'production';
    cdn?: boolean;
  }): Promise<DeploymentResult>;
}

// Simplified implementation for agencies
class AgencyWhiteLabelWorkflow implements WhiteLabelWorkflow {
  async initializeProject(clientConfig: any): Promise<ProjectInit> {
    const projectId = generateProjectId();
    const templateDir = await cloneBaseTemplate();

    // Initialize project structure
    await initializeProjectStructure(projectId, templateDir, clientConfig);

    return {
      projectId,
      templatePath: templateDir,
      status: 'initialized',
      estimatedCompletionTime: '2-4 hours'
    };
  }

  async configureBranding(projectId: string, branding: any): Promise<void> {
    // Apply client theme
    await this.applyClientTheme(projectId, branding.theme);

    // Configure logo
    await this.configureLogo(projectId, branding.logo);

    // Update content
    await this.updateContent(projectId, branding.content);

    // Generate CSS
    await this.generateProjectCSS(projectId);
  }

  async customizeComponents(projectId: string, customizations: any): Promise<void> {
    // Apply component customizations
    for (const customization of customizations.components) {
      await this.customizeComponent(projectId, customization);
    }

    // Apply layout customizations
    for (const layout of customizations.layouts) {
      await this.customizeLayout(projectId, layout);
    }
  }

  async deployMicroApp(projectId: string, deployment: any): Promise<DeploymentResult> {
    // Build project
    const buildResult = await this.buildProject(projectId);

    // Deploy to specified environment
    const deployResult = await this.deployToEnvironment(
      projectId,
      deployment.environment,
      deployment.domain
    );

    return {
      success: true,
      url: `https://${deployment.domain}`,
      deploymentId: deployResult.id,
      buildTime: buildResult.duration,
      deployTime: deployResult.duration
    };
  }
}
```

## 7. Verification Checkpoints

### 7.1 Architecture Validation

✅ **Simple component patterns defined**
- Agency-focused atomic design hierarchy established
- Essential components identified (10+ atoms, 8+ molecules, 5+ organisms)
- Component composition patterns documented
- Performance targets defined (sub-200ms render time)

✅ **Basic customization interface designed**
- ClientThemeConfig interface created
- Theme validation system designed
- CSS generation system planned
- Component theming patterns established

✅ **Simple client theming architecture planned**
- ClientThemeProvider context designed
- Theme switching system architecture defined
- CSS custom properties integration planned
- Real-time preview system designed

✅ **Component composition patterns established**
- MicroAppLayout standard pattern created
- PageBuilder rapid composition system designed
- Pre-built section components identified
- Layout template system planned

✅ **Basic customization system designed**
- ClientConfigManager interface defined
- White-label workflow process designed
- Project initialization system planned
- Deployment automation strategy defined

## 8. Implementation Readiness Assessment

### 8.1 Technical Requirements Met
- ✅ Existing HT-021 foundation leveraged
- ✅ Design token system integration planned
- ✅ Component library foundation available
- ✅ TypeScript interfaces defined
- ✅ Performance targets established

### 8.2 Agency Business Requirements Met
- ✅ Rapid development support (≤7 days delivery)
- ✅ Simple client customization (≤2 hours setup)
- ✅ White-labeling capability
- ✅ Brand consistency enforcement
- ✅ Accessibility compliance (WCAG 2.1 AA)

### 8.3 Risk Assessment
- **Low Risk**: Simple architecture with proven patterns
- **Mitigation**: Builds on existing HT-021 foundation
- **Validation**: Clear verification checkpoints defined
- **Monitoring**: Performance budgets established

## 9. Next Steps

### 9.1 Phase 1 Continuation
1. **HT-022.1.2**: Simple Design Token System
2. **HT-022.1.3**: Component Composition & Basic Customization System
3. **HT-022.1.4**: Simple Customization Framework

### 9.2 Implementation Preparation
- Architecture design complete ✅
- Interface definitions ready ✅
- Component patterns established ✅
- Customization system designed ✅
- Ready for Phase 2 implementation ✅

---

**Task Status**: ✅ **COMPLETE**
**Verification**: All checkpoints validated
**Next Action**: Proceed to HT-022.1.2 - Simple Design Token System
**Estimated Phase 1 Completion**: 4 hours remaining