#!/usr/bin/env node

/**
 * HERO INTELLIGENCE & LEARNING SYSTEM
 * 
 * This system provides artificial intelligence capabilities to the hero ecosystem,
 * including pattern recognition, predictive analytics, automated optimization,
 * and continuous learning from system behavior.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Intelligence System Configuration
const INTELLIGENCE_CONFIG = {
  name: 'Hero Intelligence & Learning System',
  version: '1.0.0',
  description: 'AI-powered analysis and optimization for the hero ecosystem',
  learningEnabled: true,
  autoOptimization: true,
  patternRecognition: true,
  predictiveAnalytics: true,
  maxMemorySize: 1000, // Maximum patterns to remember
  learningRate: 0.1, // How quickly to adapt to new patterns
  confidenceThreshold: 0.8 // Minimum confidence for auto-actions
};

// Pattern Types
const PATTERN_TYPES = {
  'performance_degradation': {
    name: 'Performance Degradation',
    indicators: ['response_time_increase', 'error_rate_spike', 'resource_usage_high'],
    actions: ['scale_resources', 'optimize_code', 'add_caching'],
    priority: 'high'
  },
  
  'security_threat': {
    name: 'Security Threat',
    indicators: ['failed_auth_attempts', 'unusual_access_patterns', 'data_exfiltration'],
    actions: ['block_ip', 'increase_monitoring', 'audit_access'],
    priority: 'critical'
  },
  
  'hero_failure': {
    name: 'Hero Failure',
    indicators: ['health_decrease', 'error_spike', 'response_timeout'],
    actions: ['auto_repair', 'restart_service', 'escalate_issue'],
    priority: 'medium'
  },
  
  'resource_optimization': {
    name: 'Resource Optimization',
    indicators: ['low_utilization', 'memory_leak', 'inefficient_queries'],
    actions: ['optimize_memory', 'add_indexes', 'cleanup_resources'],
    priority: 'low'
  }
};

// Learning Patterns
class LearningPattern {
  constructor(type, indicators, actions, outcome) {
    this.type = type;
    this.indicators = indicators;
    this.actions = actions;
    this.outcome = outcome; // 'success', 'partial', 'failure'
    this.confidence = 0.5; // Initial confidence
    this.occurrences = 1;
    this.lastSeen = Date.now();
    this.successRate = outcome === 'success' ? 1.0 : 0.0;
  }
  
  // Update pattern based on new outcome
  updatePattern(newOutcome) {
    this.occurrences++;
    this.lastSeen = Date.now();
    
    // Update success rate
    const successCount = this.outcome === 'success' ? 1 : 0;
    this.successRate = (this.successRate * (this.occurrences - 1) + successCount) / this.occurrences;
    
    // Update confidence based on success rate and occurrences
    this.confidence = Math.min(0.95, this.successRate + (this.occurrences * 0.01));
    
    // Update outcome if we have a better one
    if (newOutcome === 'success' && this.outcome !== 'success') {
      this.outcome = newOutcome;
    }
  }
  
  // Get pattern score for decision making
  getScore() {
    const recency = Math.max(0, 1 - (Date.now() - this.lastSeen) / (7 * 24 * 60 * 60 * 1000)); // 7 days
    const frequency = Math.min(1, this.occurrences / 10); // Normalize to 10 occurrences
    
    return (this.confidence * 0.4) + (this.successRate * 0.3) + (recency * 0.2) + (frequency * 0.1);
  }
}

// Hero Intelligence System
class HeroIntelligence {
  constructor() {
    this.status = 'learning';
    this.patterns = new Map();
    this.actions = [];
    this.learnings = [];
    this.startTime = Date.now();
    this.performanceMetrics = {
      responseTime: [],
      errorRate: [],
      resourceUsage: [],
      heroHealth: []
    };
  }
  
  // Initialize the intelligence system
  async initialize() {
    console.log('🧠 HERO INTELLIGENCE & LEARNING SYSTEM INITIALIZING...');
    console.log('='.repeat(60));
    
    this.status = 'learning';
    
    // Load existing patterns
    await this.loadPatterns();
    
    // Start continuous learning
    this.startLearning();
    
    console.log('✅ Intelligence System is now LEARNING and optimizing heroes!');
    return this;
  }
  
  // Load existing patterns from storage
  async loadPatterns() {
    try {
      if (fs.existsSync('data/hero-patterns.json')) {
        const patternsData = JSON.parse(fs.readFileSync('data/hero-patterns.json', 'utf8'));
        
        for (const [key, data] of Object.entries(patternsData)) {
          const pattern = new LearningPattern(
            data.type,
            data.indicators,
            data.actions,
            data.outcome
          );
          pattern.confidence = data.confidence;
          pattern.occurrences = data.occurrences;
          pattern.lastSeen = data.lastSeen;
          pattern.successRate = data.successRate;
          
          this.patterns.set(key, pattern);
        }
        
        console.log(`📚 Loaded ${this.patterns.size} existing patterns`);
      }
    } catch (error) {
      console.warn('⚠️ Could not load existing patterns:', error.message);
    }
  }
  
  // Save patterns to storage
  async savePatterns() {
    try {
      const dataDir = 'data';
      if (!fs.existsSync(dataDir)) {
        fs.mkdirSync(dataDir, { recursive: true });
      }
      
      const patternsData = {};
      for (const [key, pattern] of this.patterns) {
        patternsData[key] = {
          type: pattern.type,
          indicators: pattern.indicators,
          actions: pattern.actions,
          outcome: pattern.outcome,
          confidence: pattern.confidence,
          occurrences: pattern.occurrences,
          lastSeen: pattern.lastSeen,
          successRate: pattern.successRate
        };
      }
      
      fs.writeFileSync('data/hero-patterns.json', JSON.stringify(patternsData, null, 2));
      console.log('💾 Patterns saved to storage');
    } catch (error) {
      console.error('❌ Error saving patterns:', error.message);
    }
  }
  
  // Start continuous learning process
  startLearning() {
    console.log('🎓 Starting continuous learning process...');
    
    // Learn every 5 minutes
    setInterval(async () => {
      await this.learnFromSystem();
    }, 5 * 60 * 1000);
    
    // Initial learning
    this.learnFromSystem();
  }
  
  // Learn from current system state
  async learnFromSystem() {
    try {
      console.log('🎓 Learning from system state...');
      
      // Collect current metrics
      const metrics = await this.collectMetrics();
      
      // Analyze for patterns
      const newPatterns = await this.analyzePatterns(metrics);
      
      // Update existing patterns
      await this.updatePatterns(newPatterns);
      
      // Optimize based on learned patterns
      if (INTELLIGENCE_CONFIG.autoOptimization) {
        await this.autoOptimize();
      }
      
      // Save learned patterns
      await this.savePatterns();
      
    } catch (error) {
      console.error('❌ Error during learning:', error.message);
    }
  }
  
  // Collect current system metrics
  async collectMetrics() {
    const metrics = {
      timestamp: Date.now(),
      system: {},
      heroes: {},
      performance: {},
      security: {}
    };
    
    try {
      // Get hero system status
      const heroStatus = await this.getHeroSystemStatus();
      metrics.heroes = heroStatus;
      
      // Get performance metrics
      const perfMetrics = await this.getPerformanceMetrics();
      metrics.performance = perfMetrics;
      
      // Get security metrics
      const securityMetrics = await this.getSecurityMetrics();
      metrics.security = securityMetrics;
      
      // Store metrics for trend analysis
      this.storeMetrics(metrics);
      
    } catch (error) {
      console.warn('⚠️ Error collecting metrics:', error.message);
    }
    
    return metrics;
  }
  
  // Get hero system status
  async getHeroSystemStatus() {
    try {
      // Run hero system status command
      const result = execSync('npm run hero:status', { 
        encoding: 'utf8',
        stdio: 'pipe',
        timeout: 10000
      });
      
      return JSON.parse(result);
    } catch (error) {
      return { error: 'Could not get hero status' };
    }
  }
  
  // Get performance metrics
  async getPerformanceMetrics() {
    const metrics = {
      responseTime: this.getAverageMetric('responseTime'),
      errorRate: this.getAverageMetric('errorRate'),
      resourceUsage: this.getAverageMetric('resourceUsage'),
      heroHealth: this.getAverageMetric('heroHealth')
    };
    
    return metrics;
  }
  
  // Get security metrics
  async getSecurityMetrics() {
    try {
      // Check for security threats
      const threats = await this.checkSecurityThreats();
      
      return {
        threats: threats.length,
        criticalThreats: threats.filter(t => t.severity === 'critical').length,
        lastScan: Date.now()
      };
    } catch (error) {
      return { error: 'Could not get security metrics' };
    }
  }
  
  // Check for security threats
  async checkSecurityThreats() {
    try {
      // Run threat scan
      const result = execSync('npm run hero:threats', { 
        encoding: 'utf8',
        stdio: 'pipe',
        timeout: 10000
      });
      
      // Parse threats from output
      const threats = [];
      const lines = result.split('\n');
      
      for (const line of lines) {
        if (line.includes('CRITICAL:') || line.includes('HIGH:') || line.includes('MEDIUM:')) {
          const severity = line.includes('CRITICAL:') ? 'critical' : 
                          line.includes('HIGH:') ? 'high' : 'medium';
          
          threats.push({
            severity,
            message: line.trim(),
            timestamp: Date.now()
          });
        }
      }
      
      return threats;
    } catch (error) {
      return [];
    }
  }
  
  // Store metrics for trend analysis
  storeMetrics(metrics) {
    // Store performance metrics
    if (metrics.performance.responseTime !== undefined) {
      this.performanceMetrics.responseTime.push({
        value: metrics.performance.responseTime,
        timestamp: metrics.timestamp
      });
    }
    
    if (metrics.performance.errorRate !== undefined) {
      this.performanceMetrics.errorRate.push({
        value: metrics.performance.errorRate,
        timestamp: metrics.timestamp
      });
    }
    
    if (metrics.performance.resourceUsage !== undefined) {
      this.performanceMetrics.resourceUsage.push({
        value: metrics.performance.resourceUsage,
        timestamp: metrics.timestamp
      });
    }
    
    if (metrics.performance.heroHealth !== undefined) {
      this.performanceMetrics.heroHealth.push({
        value: metrics.performance.heroHealth,
        timestamp: metrics.timestamp
      });
    }
    
    // Keep only last 1000 metrics to prevent memory bloat
    const maxMetrics = 1000;
    for (const key in this.performanceMetrics) {
      if (this.performanceMetrics[key].length > maxMetrics) {
        this.performanceMetrics[key] = this.performanceMetrics[key].slice(-maxMetrics);
      }
    }
  }
  
  // Get average metric value
  getAverageMetric(metricName) {
    const metrics = this.performanceMetrics[metricName];
    if (!metrics || metrics.length === 0) return 0;
    
    const sum = metrics.reduce((acc, m) => acc + m.value, 0);
    return sum / metrics.length;
  }
  
  // Analyze metrics for patterns
  async analyzePatterns(metrics) {
    const patterns = [];
    
    // Analyze performance patterns
    const perfPatterns = this.analyzePerformancePatterns(metrics.performance);
    patterns.push(...perfPatterns);
    
    // Analyze security patterns
    const securityPatterns = this.analyzeSecurityPatterns(metrics.security);
    patterns.push(...securityPatterns);
    
    // Analyze hero health patterns
    const heroPatterns = this.analyzeHeroPatterns(metrics.heroes);
    patterns.push(...heroPatterns);
    
    return patterns;
  }
  
  // Analyze performance patterns
  analyzePerformancePatterns(performance) {
    const patterns = [];
    
    // Check for performance degradation
    if (performance.responseTime > 1000) { // Response time > 1 second
      patterns.push({
        type: 'performance_degradation',
        indicators: ['response_time_increase'],
        actions: ['optimize_code', 'add_caching', 'scale_resources'],
        confidence: 0.8
      });
    }
    
    // Check for high error rate
    if (performance.errorRate > 0.05) { // Error rate > 5%
      patterns.push({
        type: 'performance_degradation',
        indicators: ['error_rate_spike'],
        actions: ['debug_errors', 'add_monitoring', 'rollback_changes'],
        confidence: 0.9
      });
    }
    
    // Check for resource issues
    if (performance.resourceUsage > 0.8) { // Resource usage > 80%
      patterns.push({
        type: 'resource_optimization',
        indicators: ['resource_usage_high'],
        actions: ['scale_resources', 'optimize_memory', 'cleanup_processes'],
        confidence: 0.7
      });
    }
    
    return patterns;
  }
  
  // Analyze security patterns
  analyzeSecurityPatterns(security) {
    const patterns = [];
    
    // Check for security threats
    if (security.criticalThreats > 0) {
      patterns.push({
        type: 'security_threat',
        indicators: ['critical_threats_detected'],
        actions: ['immediate_response', 'increase_monitoring', 'audit_access'],
        confidence: 0.95
      });
    }
    
    if (security.threats > 5) {
      patterns.push({
        type: 'security_threat',
        indicators: ['multiple_threats'],
        actions: ['comprehensive_scan', 'update_defenses', 'review_policies'],
        confidence: 0.8
      });
    }
    
    return patterns;
  }
  
  // Analyze hero patterns
  analyzeHeroPatterns(heroes) {
    const patterns = [];
    
    if (heroes.system && heroes.system.systemHealth < 80) {
      patterns.push({
        type: 'hero_failure',
        indicators: ['system_health_low'],
        actions: ['diagnose_issues', 'repair_heroes', 'escalate_critical'],
        confidence: 0.8
      });
    }
    
    if (heroes.threats && heroes.threats.critical > 0) {
      patterns.push({
        type: 'hero_failure',
        indicators: ['critical_threats'],
        actions: ['immediate_response', 'activate_defenses', 'notify_team'],
        confidence: 0.9
      });
    }
    
    return patterns;
  }
  
  // Update patterns with new learnings
  async updatePatterns(newPatterns) {
    for (const newPattern of newPatterns) {
      const patternKey = this.generatePatternKey(newPattern);
      
      if (this.patterns.has(patternKey)) {
        // Update existing pattern
        const existingPattern = this.patterns.get(patternKey);
        existingPattern.updatePattern('success'); // Assume success for now
      } else {
        // Create new pattern
        const pattern = new LearningPattern(
          newPattern.type,
          newPattern.indicators,
          newPattern.actions,
          'partial' // Initial outcome
        );
        pattern.confidence = newPattern.confidence || 0.5;
        
        this.patterns.set(patternKey, pattern);
        
        // Record learning
        this.learnings.push({
          timestamp: Date.now(),
          type: 'new_pattern',
          pattern: patternKey,
          confidence: pattern.confidence
        });
      }
    }
    
    // Clean up old patterns if we exceed memory limit
    if (this.patterns.size > INTELLIGENCE_CONFIG.maxMemorySize) {
      await this.cleanupOldPatterns();
    }
  }
  
  // Generate unique key for pattern
  generatePatternKey(pattern) {
    const indicators = pattern.indicators.sort().join('|');
    const actions = pattern.actions.sort().join('|');
    return `${pattern.type}:${indicators}:${actions}`;
  }
  
  // Clean up old patterns
  async cleanupOldPatterns() {
    const patternsArray = Array.from(this.patterns.entries());
    
    // Sort by score and keep only the best ones
    patternsArray.sort((a, b) => b[1].getScore() - a[1].getScore());
    
    const patternsToKeep = patternsArray.slice(0, INTELLIGENCE_CONFIG.maxMemorySize);
    
    // Clear and repopulate
    this.patterns.clear();
    for (const [key, pattern] of patternsToKeep) {
      this.patterns.set(key, pattern);
    }
    
    console.log(`🧹 Cleaned up patterns. Kept ${this.patterns.size} best patterns.`);
  }
  
  // Auto-optimize based on learned patterns
  async autoOptimize() {
    console.log('⚡ Auto-optimizing based on learned patterns...');
    
    const highConfidencePatterns = Array.from(this.patterns.values())
      .filter(p => p.confidence >= INTELLIGENCE_CONFIG.confidenceThreshold)
      .sort((a, b) => b.getScore() - a.getScore());
    
    for (const pattern of highConfidencePatterns.slice(0, 3)) { // Top 3 patterns
      if (pattern.outcome === 'success' && pattern.successRate > 0.8) {
        await this.executeOptimization(pattern);
      }
    }
  }
  
  // Execute optimization based on pattern
  async executeOptimization(pattern) {
    try {
      console.log(`🚀 Executing optimization: ${pattern.type}`);
      console.log(`Actions: ${pattern.actions.join(', ')}`);
      console.log(`Confidence: ${(pattern.confidence * 100).toFixed(1)}%`);
      
      // Record the optimization attempt
      this.actions.push({
        timestamp: Date.now(),
        type: 'optimization',
        pattern: pattern.type,
        actions: pattern.actions,
        confidence: pattern.confidence,
        status: 'executing'
      });
      
      // Execute actions
      for (const action of pattern.actions) {
        await this.executeAction(action);
      }
      
      // Mark as completed
      const actionIndex = this.actions.length - 1;
      this.actions[actionIndex].status = 'completed';
      
      console.log(`✅ Optimization completed: ${pattern.type}`);
      
    } catch (error) {
      console.error(`❌ Optimization failed: ${pattern.type}`, error.message);
      
      // Mark as failed
      const actionIndex = this.actions.length - 1;
      if (actionIndex >= 0) {
        this.actions[actionIndex].status = 'failed';
        this.actions[actionIndex].error = error.message;
      }
    }
  }
  
  // Execute a specific action
  async executeAction(action) {
    try {
      console.log(`⚡ Executing action: ${action}`);
      
      let result;
      
      switch (action) {
        case 'optimize_code':
          result = await this.optimizeCode();
          break;
        case 'add_caching':
          result = await this.addCaching();
          break;
        case 'scale_resources':
          result = await this.scaleResources();
          break;
        case 'debug_errors':
          result = await this.debugErrors();
          break;
        case 'add_monitoring':
          result = await this.addMonitoring();
          break;
        case 'repair_heroes':
          result = await this.repairHeroes();
          break;
        case 'activate_defenses':
          result = await this.activateDefenses();
          break;
        default:
          result = `Action ${action} not implemented yet`;
      }
      
      console.log(`✅ Action completed: ${action}`);
      return result;
      
    } catch (error) {
      console.error(`❌ Action failed: ${action}`, error.message);
      throw error;
    }
  }
  
  // Specific optimization actions
  async optimizeCode() {
    // Run code optimization
    execSync('npm run lint', { stdio: 'pipe' });
    return 'Code optimization completed';
  }
  
  async addCaching() {
    // Check if caching is already implemented
    if (!fs.existsSync('lib/caching')) {
      fs.mkdirSync('lib/caching', { recursive: true });
      fs.writeFileSync('lib/caching/index.ts', '// Caching layer added by AI\n');
    }
    return 'Caching layer added';
  }
  
  async scaleResources() {
    // This would typically involve cloud provider APIs
    return 'Resource scaling initiated';
  }
  
  async debugErrors() {
    // Run error analysis
    execSync('npm run doctor', { stdio: 'pipe' });
    return 'Error debugging completed';
  }
  
  async addMonitoring() {
    // Check if monitoring is enhanced
    if (!fs.existsSync('lib/monitoring')) {
      fs.mkdirSync('lib/monitoring', { recursive: true });
      fs.writeFileSync('lib/monitoring/index.ts', '// Enhanced monitoring added by AI\n');
    }
    return 'Enhanced monitoring added';
  }
  
  async repairHeroes() {
    // Run hero repair
    execSync('npm run hero:health', { stdio: 'pipe' });
    return 'Hero health check completed';
  }
  
  async activateDefenses() {
    // Activate threat response
    execSync('npm run hero:threats', { stdio: 'pipe' });
    return 'Defenses activated';
  }
  
  // Get system intelligence report
  getIntelligenceReport() {
    const totalPatterns = this.patterns.size;
    const highConfidencePatterns = Array.from(this.patterns.values())
      .filter(p => p.confidence >= INTELLIGENCE_CONFIG.confidenceThreshold).length;
    
    const recentLearnings = this.learnings
      .filter(l => Date.now() - l.timestamp < 24 * 60 * 60 * 1000) // Last 24 hours
      .length;
    
    const recentActions = this.actions
      .filter(a => Date.now() - a.timestamp < 24 * 60 * 60 * 1000) // Last 24 hours
      .length;
    
    return {
      status: this.status,
      uptime: Date.now() - this.startTime,
      patterns: {
        total: totalPatterns,
        highConfidence: highConfidencePatterns,
        learningRate: INTELLIGENCE_CONFIG.learningRate
      },
      learnings: {
        total: this.learnings.length,
        recent: recentLearnings
      },
      actions: {
        total: this.actions.length,
        recent: recentActions,
        completed: this.actions.filter(a => a.status === 'completed').length,
        failed: this.actions.filter(a => a.status === 'failed').length
      },
      performance: {
        responseTime: this.getAverageMetric('responseTime'),
        errorRate: this.getAverageMetric('errorRate'),
        resourceUsage: this.getAverageMetric('resourceUsage'),
        heroHealth: this.getAverageMetric('heroHealth')
      }
    };
  }
  
  // Display intelligence dashboard
  displayDashboard() {
    const report = this.getIntelligenceReport();
    
    console.log('\n' + '='.repeat(60));
    console.log('🧠 HERO INTELLIGENCE & LEARNING DASHBOARD');
    console.log('='.repeat(60));
    
    console.log(`Status: ${report.status.toUpperCase()}`);
    console.log(`Uptime: ${Math.round(report.uptime / 1000)}s`);
    
    console.log('\n🧠 INTELLIGENCE:');
    console.log(`Patterns: ${report.patterns.total} (${report.patterns.highConfidence} high confidence)`);
    console.log(`Learning Rate: ${(report.patterns.learningRate * 100).toFixed(1)}%`);
    
    console.log('\n📚 LEARNING:');
    console.log(`Total Learnings: ${report.learnings.total}`);
    console.log(`Recent (24h): ${report.learnings.recent}`);
    
    console.log('\n⚡ ACTIONS:');
    console.log(`Total Actions: ${report.actions.total}`);
    console.log(`Recent (24h): ${report.actions.recent}`);
    console.log(`Completed: ${report.actions.completed} | Failed: ${report.actions.failed}`);
    
    console.log('\n📊 PERFORMANCE:');
    console.log(`Response Time: ${report.performance.responseTime.toFixed(2)}ms`);
    console.log(`Error Rate: ${(report.performance.errorRate * 100).toFixed(2)}%`);
    console.log(`Resource Usage: ${(report.performance.resourceUsage * 100).toFixed(1)}%`);
    console.log(`Hero Health: ${(report.performance.heroHealth * 100).toFixed(1)}%`);
    
    // Show top patterns
    if (this.patterns.size > 0) {
      console.log('\n🏆 TOP PATTERNS:');
      const topPatterns = Array.from(this.patterns.values())
        .sort((a, b) => b.getScore() - a.getScore())
        .slice(0, 5);
      
      for (const pattern of topPatterns) {
        console.log(`  ${pattern.type}: ${(pattern.confidence * 100).toFixed(1)}% confidence, ${pattern.occurrences} occurrences`);
      }
    }
    
    console.log('\n' + '='.repeat(60));
  }
}

// CLI Interface
async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || 'start';
  
  const intelligence = new HeroIntelligence();
  
  try {
    switch (command) {
      case 'start':
        await intelligence.initialize();
        // Keep running for continuous learning
        process.on('SIGINT', () => {
          console.log('\n🛑 Intelligence System shutting down...');
          process.exit(0);
        });
        break;
      case 'dashboard':
        await intelligence.initialize();
        intelligence.displayDashboard();
        break;
      case 'learn':
        await intelligence.initialize();
        await intelligence.learnFromSystem();
        console.log('✅ Learning cycle completed');
        break;
      case 'optimize':
        await intelligence.initialize();
        await intelligence.autoOptimize();
        console.log('✅ Auto-optimization completed');
        break;
      case 'patterns':
        await intelligence.initialize();
        console.log('📚 PATTERN LIBRARY:');
        for (const [key, pattern] of intelligence.patterns) {
          console.log(`${key}: ${(pattern.confidence * 100).toFixed(1)}% confidence, ${pattern.occurrences} occurrences`);
        }
        break;
      default:
        console.log('Available commands:');
        console.log('  start      - Start intelligence system (default)');
        console.log('  dashboard  - Show intelligence dashboard');
        console.log('  learn      - Run learning cycle');
        console.log('  optimize   - Run auto-optimization');
        console.log('  patterns   - Show learned patterns');
    }
  } catch (error) {
    console.error('❌ Intelligence System Error:', error.message);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { HeroIntelligence, LearningPattern, PATTERN_TYPES };
