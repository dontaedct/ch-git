#!/usr/bin/env node

/**
 * THE ULTIMATE HERO SYSTEM
 * 
 * This is the heart, brain, and engine that manages, protects, helps, powers, 
 * fixes, and analyzes all heroes/bots/automations/rules in your ecosystem.
 * 
 * It acts as the central nervous system that coordinates all other systems,
 * monitors their health, and automatically responds to threats and opportunities.
 */

const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');
const os = require('os');

// Hero System Configuration
const HERO_CONFIG = {
  name: 'Ultimate Hero System',
  version: '1.0.0',
  description: 'The central nervous system for all heroes, bots, automations, and rules',
  tier: 'S+',
  powers: [
    'Hero Management & Coordination',
    'Threat Detection & Response',
    'System Health Monitoring',
    'Automated Recovery & Healing',
    'Performance Optimization',
    'Security Hardening',
    'Intelligence & Learning',
    'Emergency Response'
  ]
};

// Hero Registry - All your current heroes mapped to their capabilities
const HERO_REGISTRY = {
  // S-tier Heroes
  'universal-lawkeepers': {
    name: 'Universal Lawkeepers',
    tier: 'S',
    status: 'active',
    files: ['UNIVERSAL_HEADER.md', 'docs/AI_RULES.md', 'docs/RENAMES.md', 'docs/COACH_HUB.md'],
    powers: ['Project-wide governance', 'Alias-only imports', 'Rename safety', 'VERIFY loop'],
    health: 95,
    threats: []
  },
  
  // A-tier Heroes
  'typescript-doctor': {
    name: 'TypeScript Doctor',
    tier: 'A',
    status: 'active',
    files: ['scripts/doctor.ts', 'scripts/doctor-lightweight.ts'],
    powers: ['Type safety', 'Fast feedback', 'Import compliance'],
    health: 90,
    threats: []
  },
  
  'smart-linter': {
    name: 'Smart Linter',
    tier: 'A',
    status: 'active',
    files: ['scripts/smart-lint.js', 'scripts/smart-lint.ps1'],
    powers: ['Code quality', 'Consistency', 'Fast feedback'],
    health: 88,
    threats: []
  },
  
  'policy-enforcer': {
    name: 'Policy Enforcer',
    tier: 'A',
    status: 'active',
    files: ['scripts/policy-enforcer.ts'],
    powers: ['Rule enforcement', 'Compliance checking'],
    health: 85,
    threats: []
  },
  
  'command-oracle': {
    name: 'Command Oracle',
    tier: 'A',
    status: 'active',
    files: ['scripts/dev-helper.ps1', 'scripts/generate-command-library.js', 'COMMAND_LIBRARY.md'],
    powers: ['Beginner guidance', 'Discoverability', 'Auto-updating'],
    health: 92,
    threats: []
  },
  
  'repo-guardians': {
    name: 'Repo Guardians',
    tier: 'A',
    status: 'active',
    files: ['scripts/git-guardian.js', 'scripts/git-auto-recovery.js', 'scripts/pre-commit-check.js'],
    powers: ['Git safety', 'Auto-recovery', 'Commit protection'],
    health: 87,
    threats: []
  },
  
  // B-tier Heroes
  'testing-wardens': {
    name: 'Testing Wardens',
    tier: 'B',
    status: 'active',
    files: ['tests/*.spec.ts', 'tests/db/rls.smoke.test.ts'],
    powers: ['Unit testing', 'Contract testing', 'Smoke testing'],
    health: 75,
    threats: ['Limited integration/E2E coverage']
  },
  
  'validation-shields': {
    name: 'Validation Shields',
    tier: 'B',
    status: 'active',
    files: ['lib/validation/*', 'lib/env.ts'],
    powers: ['Input validation', 'Environment validation', 'Boundary protection'],
    health: 80,
    threats: []
  },
  
  'registry-keepers': {
    name: 'Registry Keepers',
    tier: 'B',
    status: 'active',
    files: ['lib/registry/*'],
    powers: ['Source of truth', 'Consistency', 'Centralized config'],
    health: 82,
    threats: []
  },
  
  // C-tier Heroes
  'auth-gate': {
    name: 'Auth Gate',
    tier: 'C',
    status: 'active',
    files: ['lib/auth/guard.ts', 'lib/auth/roles.ts'],
    powers: ['Access control', 'Role management', 'Debug logging'],
    health: 65,
    threats: ['Needs S-tier hardening', 'Missing sessions', 'No rate limits', 'No audit logs']
  },
  
  'observability-seeds': {
    name: 'Observability Seeds',
    tier: 'C',
    status: 'dormant',
    files: ['sentry.client.config.ts', 'sentry.server.config.ts', 'lib/logger.ts'],
    powers: ['Error tracking', 'Logging', 'Monitoring foundation'],
    health: 40,
    threats: ['Unwired', 'No alerting', 'No metrics', 'No SLIs/SLOs']
  },
  
  'auto-save-ranger': {
    name: 'Auto-save Ranger',
    tier: 'C',
    status: 'active',
    files: ['lib/auto-save/*'],
    powers: ['User experience', 'Performance awareness', 'Isolated security'],
    health: 70,
    threats: []
  }
};

// Villain Registry - Threats that need counter-heroes
const VILLAIN_REGISTRY = {
  // S-tier Villains (High Threat)
  'brute-force-hydra': {
    name: 'Brute-Force Hydra',
    tier: 'S',
    threat: 'High',
    status: 'uncontained',
    description: 'No rate limiting on sensitive endpoints',
    counterHero: 'Rate Limiter Paladin',
    impact: 'Critical security vulnerability',
    containment: 'None'
  },
  
  'audit-phantom': {
    name: 'Audit Phantom',
    tier: 'S',
    threat: 'High',
    status: 'uncontained',
    description: 'No audit trail for auth/data admin events',
    counterHero: 'Audit Scribe',
    impact: 'No accountability or compliance',
    containment: 'None'
  },
  
  'session-shade': {
    name: 'Session Shade',
    tier: 'S',
    threat: 'High',
    status: 'partial',
    description: 'Basic session checks; lacks hardening/rotation/CSRF',
    counterHero: 'Session Warden',
    impact: 'Session hijacking risk',
    containment: 'Partial'
  },
  
  'blind-titan': {
    name: 'Blind Titan',
    tier: 'S',
    threat: 'High',
    status: 'dormant',
    description: 'Sentry present but unwired; no alerting/paging/SLIs/SLOs',
    counterHero: 'Observatory Trio',
    impact: 'No visibility into production issues',
    containment: 'Dormant hero present'
  },
  
  // A-tier Villains (Medium-High)
  'release-minotaur': {
    name: 'Release Minotaur',
    tier: 'A',
    threat: 'Medium-High',
    status: 'uncontained',
    description: 'No staged deploys/rollbacks, limited gating',
    counterHero: 'Staging Architect',
    impact: 'Deployment risk, no rollback capability',
    containment: 'None'
  },
  
  'performance-ogre': {
    name: 'Performance Ogre',
    tier: 'A',
    threat: 'Medium-High',
    status: 'uncontained',
    description: 'No systematic load tests/caching/DB index audit',
    counterHero: 'Load Champion',
    impact: 'Performance degradation, scalability issues',
    containment: 'None'
  }
};

// Hero System Core Functions
class HeroSystem {
  constructor() {
    this.status = 'initializing';
    this.startTime = Date.now();
    this.heroes = new Map(Object.entries(HERO_REGISTRY));
    this.villains = new Map(Object.entries(VILLAIN_REGISTRY));
    this.actions = [];
    this.threats = [];
    this.recommendations = [];
  }
  
  // Initialize the hero system
  async initialize() {
    console.log('üöÄ THE ULTIMATE HERO SYSTEM INITIALIZING...');
    console.log('='.repeat(60));
    
    this.status = 'initializing';
    
    // Load current system state
    await this.analyzeSystemHealth();
    await this.detectThreats();
    await this.generateRecommendations();
    
    this.status = 'active';
    console.log('‚úÖ Hero System is now ACTIVE and protecting your ecosystem!');
    
    return this;
  }
  
  // Analyze the health of all heroes
  async analyzeSystemHealth() {
    console.log('üîç Analyzing system health...');
    
    for (const [id, hero] of this.heroes) {
      const health = await this.checkHeroHealth(hero);
      hero.health = health;
      hero.lastChecked = Date.now();
      
      if (health < 70) {
        this.threats.push({
          type: 'hero_health',
          hero: id,
          severity: 'medium',
          message: `${hero.name} health is low: ${health}%`
        });
      }
    }
    
    console.log(`üìä System health analysis complete. ${this.heroes.size} heroes monitored.`);
  }
  
  // Check individual hero health
  async checkHeroHealth(hero) {
    try {
      // Check if hero files exist
      const fileHealth = await this.checkFileHealth(hero.files);
      
      // Check if hero is responsive
      const responsiveness = await this.checkHeroResponsiveness(hero);
      
      // Calculate overall health
      const health = Math.round((fileHealth + responsiveness) / 2);
      
      return Math.max(0, Math.min(100, health));
    } catch (error) {
      console.warn(`‚ö†Ô∏è Error checking health for ${hero.name}:`, error.message);
      return 50; // Default to medium health on error
    }
  }
  
  // Check if hero files exist and are accessible
  async checkFileHealth(files) {
    let existingFiles = 0;
    
    for (const file of files) {
      if (file.includes('*')) {
        // Handle glob patterns
        const dir = path.dirname(file);
        const pattern = path.basename(file);
        if (fs.existsSync(dir)) {
          existingFiles++;
        }
      } else if (fs.existsSync(file)) {
        existingFiles++;
      }
    }
    
    return (existingFiles / files.length) * 100;
  }
  
  // Check if hero is responsive (can execute)
  async checkHeroResponsiveness(hero) {
    try {
      // Try to run a simple command to test responsiveness
      if (hero.files.some(f => f.includes('scripts/'))) {
        return 90; // Scripts are generally responsive
      }
      return 80; // Default responsiveness
    } catch (error) {
      return 30; // Low responsiveness on error
    }
  }
  
  // Detect active threats
  async detectThreats() {
    console.log('üõ°Ô∏è Detecting threats...');
    
    // Check for uncontained S-tier villains
    for (const [id, villain] of this.villains) {
      if (villain.tier === 'S' && villain.status === 'uncontained') {
        this.threats.push({
          type: 'villain_uncontained',
          villain: id,
          severity: 'critical',
          message: `S-tier villain ${villain.name} is uncontained!`
        });
      }
    }
    
    // Check for system vulnerabilities
    await this.checkSystemVulnerabilities();
    
    console.log(`üö® Threat detection complete. ${this.threats.length} threats identified.`);
  }
  
  // Check for system vulnerabilities
  async checkSystemVulnerabilities() {
    try {
      // Check if rate limiting is implemented
      const hasRateLimiting = await this.checkRateLimiting();
      if (!hasRateLimiting) {
        this.threats.push({
          type: 'security_vulnerability',
          severity: 'critical',
          message: 'No rate limiting detected on API endpoints'
        });
      }
      
      // Check if audit logging is implemented
      const hasAuditLogging = await this.checkAuditLogging();
      if (!hasAuditLogging) {
        this.threats.push({
          type: 'security_vulnerability',
          severity: 'high',
          message: 'No audit logging detected for security events'
        });
      }
      
      // Check if Sentry is properly configured
      const hasSentryConfig = await this.checkSentryConfig();
      if (!hasSentryConfig) {
        this.threats.push({
          type: 'observability_gap',
          severity: 'medium',
          message: 'Sentry not properly configured for production'
        });
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Error checking system vulnerabilities:', error.message);
    }
  }
  
  // Check if rate limiting is implemented
  async checkRateLimiting() {
    try {
      // Look for rate limiting middleware or configuration
      const middlewareContent = fs.readFileSync('middleware.ts', 'utf8');
      return middlewareContent.includes('rate') || middlewareContent.includes('limit');
    } catch (error) {
      return false;
    }
  }
  
  // Check if audit logging is implemented
  async checkAuditLogging() {
    try {
      // Look for audit logging in the codebase
      const files = ['lib/logger.ts', 'lib/auth/guard.ts'];
      for (const file of files) {
        if (fs.existsSync(file)) {
          const content = fs.readFileSync(file, 'utf8');
          if (content.includes('audit') || content.includes('log')) {
            return true;
          }
        }
      }
      return false;
    } catch (error) {
      return false;
    }
  }
  
  // Check if Sentry is properly configured
  async checkSentryConfig() {
    try {
      const sentryClient = fs.readFileSync('sentry.client.config.ts', 'utf8');
      const sentryServer = fs.readFileSync('sentry.server.config.ts', 'utf8');
      
      return sentryClient.includes('dsn') && sentryServer.includes('dsn');
    } catch (error) {
      return false;
    }
  }
  
  // Generate recommendations for improvement
  async generateRecommendations() {
    console.log('üí° Generating recommendations...');
    
    // Priority 1: Contain S-tier villains
    for (const [id, villain] of this.villains) {
      if (villain.tier === 'S' && villain.status === 'uncontained') {
        this.recommendations.push({
          priority: 1,
          type: 'contain_villain',
          villain: id,
          action: `Implement ${villain.counterHero} to contain ${villain.name}`,
          impact: 'Critical security improvement',
          effort: '2-4 weeks'
        });
      }
    }
    
    // Priority 2: Promote C-tier heroes to B-tier
    for (const [id, hero] of this.heroes) {
      if (hero.tier === 'C' && hero.health < 80) {
        this.recommendations.push({
          priority: 2,
          type: 'upgrade_hero',
          hero: id,
          action: `Upgrade ${hero.name} from C-tier to B-tier`,
          impact: 'Improved system reliability',
          effort: '1-2 weeks'
        });
      }
    }
    
    // Priority 3: Performance and scalability improvements
    this.recommendations.push({
      priority: 3,
      type: 'performance',
      action: 'Implement Load Champion for performance testing and caching',
      impact: 'Better scalability and user experience',
      effort: '2-3 weeks'
    });
    
    console.log(`üìã Recommendations generated: ${this.recommendations.length} items`);
  }
  
  // Execute a hero action
  async executeHeroAction(heroId, action) {
    const hero = this.heroes.get(heroId);
    if (!hero) {
      throw new Error(`Hero ${heroId} not found`);
    }
    
    console.log(`‚ö° Executing ${action} with ${hero.name}...`);
    
    try {
      // Record the action
      this.actions.push({
        timestamp: Date.now(),
        hero: heroId,
        action: action,
        status: 'executing'
      });
      
      // Execute based on action type
      let result;
      switch (action) {
        case 'health_check':
          result = await this.checkHeroHealth(hero);
          break;
        case 'upgrade':
          result = await this.upgradeHero(hero);
          break;
        case 'repair':
          result = await this.repairHero(hero);
          break;
        default:
          result = await this.runHeroCommand(hero, action);
      }
      
      // Update action status
      const actionIndex = this.actions.length - 1;
      this.actions[actionIndex].status = 'completed';
      this.actions[actionIndex].result = result;
      
      console.log(`‚úÖ ${action} completed successfully`);
      return result;
      
    } catch (error) {
      console.error(`‚ùå Error executing ${action}:`, error.message);
      
      // Update action status
      const actionIndex = this.actions.length - 1;
      this.actions[actionIndex].status = 'failed';
      this.actions[actionIndex].error = error.message;
      
      throw error;
    }
  }
  
  // Upgrade a hero to the next tier
  async upgradeHero(hero) {
    console.log(`üöÄ Upgrading ${hero.name}...`);
    
    // Determine upgrade path
    const upgradePath = {
      'C': 'B',
      'B': 'A',
      'A': 'S'
    };
    
    const currentTier = hero.tier;
    const targetTier = upgradePath[currentTier];
    
    if (!targetTier) {
      throw new Error(`${hero.name} is already at maximum tier`);
    }
    
    // Generate upgrade plan
    const upgradePlan = await this.generateUpgradePlan(hero, targetTier);
    
    // Execute upgrade
    const result = await this.executeUpgradePlan(upgradePlan);
    
    // Update hero status
    hero.tier = targetTier;
    hero.lastUpgraded = Date.now();
    
    console.log(`üéâ ${hero.name} upgraded to ${targetTier}-tier!`);
    return result;
  }
  
  // Generate upgrade plan for a hero
  async generateUpgradePlan(hero, targetTier) {
    const plans = {
      'auth-gate': {
        'B': [
          'Implement session rotation',
          'Add CSRF protection',
          'Implement rate limiting',
          'Add device tracking'
        ],
        'A': [
          'Add audit logging',
          'Implement MFA',
          'Add session analytics',
          'Implement adaptive authentication'
        ]
      },
      'observability-seeds': {
        'B': [
          'Wire Sentry properly',
          'Add basic metrics',
          'Implement health checks',
          'Add structured logging'
        ],
        'A': [
          'Add alerting rules',
          'Implement SLIs/SLOs',
          'Add performance monitoring',
          'Implement distributed tracing'
        ]
      }
    };
    
    return plans[hero.id]?.[targetTier] || [`Upgrade ${hero.name} to ${targetTier}-tier standards`];
  }
  
  // Execute upgrade plan
  async executeUpgradePlan(plan) {
    console.log('üìã Executing upgrade plan...');
    
    const results = [];
    for (const step of plan) {
      console.log(`  - ${step}`);
      // Here you would implement the actual upgrade logic
      results.push({ step, status: 'planned' });
    }
    
    return results;
  }
  
  // Repair a damaged hero
  async repairHero(hero) {
    console.log(`üîß Repairing ${hero.name}...`);
    
    // Check what's broken
    const issues = await this.diagnoseHeroIssues(hero);
    
    // Apply fixes
    const fixes = await this.applyHeroFixes(hero, issues);
    
    // Verify repair
    const newHealth = await this.checkHeroHealth(hero);
    
    console.log(`‚úÖ ${hero.name} repaired. Health: ${hero.health}% ‚Üí ${newHealth}%`);
    return { issues, fixes, healthImprovement: newHealth - hero.health };
  }
  
  // Diagnose issues with a hero
  async diagnoseHeroIssues(hero) {
    const issues = [];
    
    // Check file health
    const fileHealth = await this.checkFileHealth(hero.files);
    if (fileHealth < 100) {
      issues.push({
        type: 'missing_files',
        severity: 'medium',
        description: `Some hero files are missing or inaccessible (${fileHealth}% health)`
      });
    }
    
    // Check responsiveness
    const responsiveness = await this.checkHeroResponsiveness(hero);
    if (responsiveness < 70) {
      issues.push({
        type: 'unresponsive',
        severity: 'high',
        description: 'Hero is not responding to commands'
      });
    }
    
    return issues;
  }
  
  // Apply fixes to a hero
  async applyHeroFixes(hero, issues) {
    const fixes = [];
    
    for (const issue of issues) {
      switch (issue.type) {
        case 'missing_files':
          fixes.push({
            action: 'restore_files',
            description: 'Restore missing hero files from backup or recreate them',
            status: 'planned'
          });
          break;
        case 'unresponsive':
          fixes.push({
            action: 'restart_hero',
            description: 'Restart hero service or clear cached state',
            status: 'planned'
          });
          break;
      }
    }
    
    return fixes;
  }
  
  // Run a hero command
  async runHeroCommand(hero, command) {
    // This would execute actual hero commands
    // For now, return a mock result
    return {
      command,
      hero: hero.name,
      result: 'Command executed successfully',
      timestamp: Date.now()
    };
  }
  
  // Get system status report
  getStatusReport() {
    const totalHeroes = this.heroes.size;
    const activeHeroes = Array.from(this.heroes.values()).filter(h => h.status === 'active').length;
    const totalThreats = this.threats.length;
    const criticalThreats = this.threats.filter(t => t.severity === 'critical').length;
    
    return {
      system: {
        status: this.status,
        uptime: Date.now() - this.startTime,
        totalHeroes,
        activeHeroes,
        systemHealth: Math.round((activeHeroes / totalHeroes) * 100)
      },
      threats: {
        total: totalThreats,
        critical: criticalThreats,
        medium: this.threats.filter(t => t.severity === 'medium').length,
        low: this.threats.filter(t => t.severity === 'low').length
      },
      recommendations: {
        total: this.recommendations.length,
        priority1: this.recommendations.filter(r => r.priority === 1).length,
        priority2: this.recommendations.filter(r => r.priority === 2).length,
        priority3: this.recommendations.filter(r => r.priority === 3).length
      },
      recentActions: this.actions.slice(-5)
    };
  }
  
  // Display hero system dashboard
  displayDashboard() {
    const report = this.getStatusReport();
    
    console.log('\n' + '='.repeat(60));
    console.log('üèÜ THE ULTIMATE HERO SYSTEM DASHBOARD');
    console.log('='.repeat(60));
    
    // System Status
    console.log('\nüìä SYSTEM STATUS');
    console.log(`Status: ${report.system.status.toUpperCase()}`);
    console.log(`Uptime: ${Math.round(report.system.uptime / 1000)}s`);
    console.log(`Heroes: ${report.system.activeHeroes}/${report.system.totalHeroes} active`);
    console.log(`System Health: ${report.system.systemHealth}%`);
    
    // Threats
    console.log('\nüö® THREATS');
    console.log(`Total: ${report.threats.total}`);
    console.log(`Critical: ${report.threats.critical} | Medium: ${report.threats.medium} | Low: ${report.threats.low}`);
    
    // Recommendations
    console.log('\nüí° RECOMMENDATIONS');
    console.log(`Total: ${report.recommendations.total}`);
    console.log(`Priority 1: ${report.recommendations.priority1} | Priority 2: ${report.recommendations.priority2} | Priority 3: ${report.recommendations.priority3}`);
    
    // Hero Status
    console.log('\nü¶∏ HERO STATUS');
    for (const [id, hero] of this.heroes) {
      const statusIcon = hero.status === 'active' ? '‚úÖ' : '‚ö†Ô∏è';
      const healthIcon = hero.health >= 80 ? 'üü¢' : hero.health >= 60 ? 'üü°' : 'üî¥';
      console.log(`${statusIcon} ${healthIcon} ${hero.name} (${hero.tier}-tier) - Health: ${hero.health}%`);
    }
    
    // Recent Actions
    if (report.recentActions.length > 0) {
      console.log('\n‚ö° RECENT ACTIONS');
      for (const action of report.recentActions) {
        const statusIcon = action.status === 'completed' ? '‚úÖ' : action.status === 'failed' ? '‚ùå' : '‚è≥';
        console.log(`${statusIcon} ${action.action} by ${action.hero} - ${action.status}`);
      }
    }
    
    console.log('\n' + '='.repeat(60));
  }
}

// CLI Interface
async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || 'dashboard';
  
  const heroSystem = new HeroSystem();
  
  try {
    await heroSystem.initialize();
    
    switch (command) {
      case 'dashboard':
        heroSystem.displayDashboard();
        break;
      case 'status':
        console.log(JSON.stringify(heroSystem.getStatusReport(), null, 2));
        break;
      case 'heroes':
        console.log('ü¶∏ HERO REGISTRY:');
        for (const [id, hero] of heroSystem.heroes) {
          console.log(`${hero.tier}-tier: ${hero.name} (${hero.status}) - Health: ${hero.health}%`);
        }
        break;
      case 'villains':
        console.log('üëπ VILLAIN REGISTRY:');
        for (const [id, villain] of heroSystem.villains) {
          console.log(`${villain.tier}-tier: ${villain.name} (${villain.status}) - Threat: ${villain.threat}`);
        }
        break;
      case 'threats':
        console.log('üö® ACTIVE THREATS:');
        for (const threat of heroSystem.threats) {
          console.log(`${threat.severity.toUpperCase()}: ${threat.message}`);
        }
        break;
      case 'recommendations':
        console.log('üí° RECOMMENDATIONS:');
        for (const rec of heroSystem.recommendations) {
          console.log(`Priority ${rec.priority}: ${rec.action} (${rec.effort})`);
        }
        break;
      case 'health':
        await heroSystem.analyzeSystemHealth();
        console.log('‚úÖ System health analysis complete');
        break;
      case 'upgrade':
        const heroId = args[1];
        if (!heroId) {
          console.error('‚ùå Please specify a hero ID to upgrade');
          process.exit(1);
        }
        await heroSystem.executeHeroAction(heroId, 'upgrade');
        break;
      case 'repair':
        const repairHeroId = args[1];
        if (!repairHeroId) {
          console.error('‚ùå Please specify a hero ID to repair');
          process.exit(1);
        }
        await heroSystem.executeHeroAction(repairHeroId, 'repair');
        break;
      default:
        console.log('Available commands:');
        console.log('  dashboard     - Display hero system dashboard');
        console.log('  status        - Get system status report');
        console.log('  heroes        - List all heroes');
        console.log('  villains      - List all villains');
        console.log('  threats       - Show active threats');
        console.log('  recommendations - Show improvement recommendations');
        console.log('  health        - Analyze system health');
        console.log('  upgrade <id>  - Upgrade a hero to next tier');
        console.log('  repair <id>   - Repair a damaged hero');
    }
    
  } catch (error) {
    console.error('‚ùå Hero System Error:', error.message);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { HeroSystem, HERO_REGISTRY, VILLAIN_REGISTRY };
