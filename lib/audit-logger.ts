/**
 * Audit Scribe - Comprehensive Audit Logging System
 * Generated by Hero System
 * 
 * Tracks all API operations, user actions, and system events for security and compliance
 * Addresses Audit Phantom threat and provides complete audit trail
 * 
 * Generated at: 2025-01-27
 */

import { NextRequest, NextResponse } from 'next/server';

// Audit event types
export enum AuditEventType {
  // Authentication events
  USER_LOGIN = 'user_login',
  USER_LOGOUT = 'user_logout',
  USER_REGISTRATION = 'user_registration',
  PASSWORD_CHANGE = 'password_change',
  PASSWORD_RESET = 'password_reset',
  
  // Data access events
  DATA_READ = 'data_read',
  DATA_CREATE = 'data_create',
  DATA_UPDATE = 'data_update',
  DATA_DELETE = 'data_delete',
  DATA_EXPORT = 'data_export',
  
  // System events
  SYSTEM_STARTUP = 'system_startup',
  SYSTEM_SHUTDOWN = 'system_shutdown',
  CONFIGURATION_CHANGE = 'configuration_change',
  SECURITY_EVENT = 'security_event',
  
  // API events
  API_REQUEST = 'api_request',
  API_RESPONSE = 'api_response',
  API_ERROR = 'api_error',
  
  // User management events
  USER_CREATED = 'user_created',
  USER_UPDATED = 'user_updated',
  USER_DELETED = 'user_deleted',
  ROLE_CHANGED = 'role_changed',
  PERMISSION_GRANTED = 'permission_granted',
  PERMISSION_REVOKED = 'permission_revoked'
}

// Audit event severity levels
export enum AuditSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

// Audit event interface
export interface AuditEvent {
  id: string;
  timestamp: string;
  eventType: AuditEventType;
  severity: AuditSeverity;
  userId?: string;
  userEmail?: string;
  userIp?: string;
  userAgent?: string;
  endpoint?: string;
  method?: string;
  resourceId?: string;
  resourceType?: string;
  action?: string;
  details?: Record<string, unknown>;
  outcome: 'success' | 'failure' | 'pending';
  errorMessage?: string;
  correlationId?: string;
  sessionId?: string;
  metadata?: Record<string, unknown>;
}

// Audit logger configuration
export interface AuditLoggerConfig {
  enabled: boolean;
  logLevel: AuditSeverity;
  includeHeaders: boolean;
  includeBody: boolean;
  includeQueryParams: boolean;
  maxBodySize: number;
  storage: 'file' | 'database' | 'external';
  retentionDays: number;
  encryption: boolean;
  compression: boolean;
}

// Default configuration
const DEFAULT_CONFIG: AuditLoggerConfig = {
  enabled: true,
  logLevel: AuditSeverity.LOW,
  includeHeaders: true,
  includeBody: false,
  includeQueryParams: true,
  maxBodySize: 1024, // 1KB
  storage: 'file',
  retentionDays: 90,
  encryption: false,
  compression: true
};

// Audit Logger Class
export class AuditLogger {
  private config: AuditLoggerConfig;
  private eventQueue: AuditEvent[] = [];
  private isProcessing = false;
  private correlationIdCounter = 0;

  constructor(config: Partial<AuditLoggerConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.startup();
  }

  // Initialize the audit logger
  private startup() {
    if (this.config.enabled) {
      // eslint-disable-next-line no-console
      console.log('[Audit Scribe] Initialized with configuration:', this.config);
      
      // Start processing queue
      setInterval(() => this.processQueue(), 1000);
      
      // Log system startup
      this.logSystemEvent(AuditEventType.SYSTEM_STARTUP, AuditSeverity.LOW, 'Audit system initialized');
    }
  }

  // Generate unique correlation ID
  private generateCorrelationId(): string {
    this.correlationIdCounter++;
    return `corr_${Date.now()}_${this.correlationIdCounter}`;
  }

  // Sanitize sensitive data
  private sanitizeData(data: unknown, maxSize: number = this.config.maxBodySize): unknown {
    if (!data) return data;
    
    const sensitiveFields = ['password', 'token', 'secret', 'key', 'authorization'];
    const sanitized = { ...data as Record<string, unknown> };
    
    // Remove sensitive fields
    sensitiveFields.forEach(field => {
      if (sanitized[field]) {
        sanitized[field] = '[REDACTED]';
      }
    });
    
    // Truncate large data
    const dataStr = JSON.stringify(sanitized);
    if (dataStr.length > maxSize) {
      return { ...sanitized, _truncated: true, _originalSize: dataStr.length };
    }
    
    return sanitized;
  }

  // Log an audit event
  public logEvent(event: Partial<AuditEvent>): void {
    if (!this.config.enabled) return;
    
    const fullEvent: AuditEvent = {
      id: `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
      eventType: event.eventType ?? AuditEventType.API_REQUEST,
      severity: event.severity ?? AuditSeverity.LOW,
      outcome: event.outcome ?? 'success',
      correlationId: event.correlationId ?? this.generateCorrelationId(),
      ...event
    };
    
    // Add to queue for processing
    this.eventQueue.push(fullEvent);
    
    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      // eslint-disable-next-line no-console
      console.log('[Audit Scribe]', fullEvent);
    }
  }

  // Log system events
  public logSystemEvent(eventType: AuditEventType, severity: AuditSeverity, message: string, details?: Record<string, unknown>): void {
    this.logEvent({
      eventType,
      severity,
      details: { message, ...details },
      outcome: 'success'
    });
  }

  // Log API requests
  public logApiRequest(req: NextRequest, userId?: string, userEmail?: string): string {
    const correlationId = this.generateCorrelationId();
    
    // Extended NextRequest interface for IP access
    interface ExtendedRequest extends NextRequest {
      ip?: string;
    }
    
    this.logEvent({
      eventType: AuditEventType.API_REQUEST,
      severity: AuditSeverity.LOW,
      userId,
      userEmail,
      userIp: (req as ExtendedRequest).ip ?? req.headers.get('x-forwarded-for') ?? 'unknown',
      userAgent: req.headers.get('user-agent') ?? undefined,
      endpoint: req.nextUrl.pathname,
      method: req.method,
      correlationId,
      sessionId: req.headers.get('x-session-id') ?? undefined,
      outcome: 'pending'
    });
    
    return correlationId;
  }

  // Log API responses
  public logApiResponse(correlationId: string, response: NextResponse, outcome: 'success' | 'failure', errorMessage?: string): void {
    this.logEvent({
      eventType: AuditEventType.API_RESPONSE,
      severity: outcome === 'failure' ? AuditSeverity.HIGH : AuditSeverity.LOW,
      correlationId,
      outcome,
      errorMessage,
      details: {
        statusCode: response.status,
        statusText: response.statusText,
        headers: this.config.includeHeaders ? Object.fromEntries(response.headers) : undefined
      }
    });
  }

  // Log data operations
  public logDataOperation(
    eventType: AuditEventType,
    userId: string,
    userEmail: string,
    resourceType: string,
    resourceId: string,
    action: string,
    details?: Record<string, unknown>,
    severity: AuditSeverity = AuditSeverity.MEDIUM
  ): void {
    this.logEvent({
      eventType,
      severity,
      userId,
      userEmail,
      resourceType,
      resourceId,
      action,
      details: this.sanitizeData(details) as Record<string, unknown> | undefined,
      outcome: 'success'
    });
  }

  // Log security events
  public logSecurityEvent(
    eventType: AuditEventType,
    severity: AuditSeverity,
    userId?: string,
    userEmail?: string,
    details?: Record<string, unknown>
  ): void {
    this.logEvent({
      eventType,
      severity,
      details: this.sanitizeData(details) as Record<string, unknown> | undefined,
      outcome: 'failure'
    });
  }

  // Process the event queue
  private async processQueue(): Promise<void> {
    if (this.isProcessing || this.eventQueue.length === 0) return;
    
    this.isProcessing = true;
    
    try {
      const events = [...this.eventQueue];
      this.eventQueue = [];
      
      // Process events based on storage configuration
      switch (this.config.storage) {
        case 'file':
          await this.writeToFile(events);
          break;
        case 'database':
          await this.writeToDatabase(events);
          break;
        case 'external':
          await this.writeToExternal(events);
          break;
      }
    } catch (error) {
      console.error('[Audit Scribe] Error processing queue:', error);
      // Re-add events to queue for retry
      this.eventQueue.unshift(...this.eventQueue);
    } finally {
      this.isProcessing = false;
    }
  }

  // Write events to file
  private async writeToFile(events: AuditEvent[]): Promise<void> {
    const fs = await import('fs/promises');
    const path = await import('path');
    
    const logDir = path.join(process.cwd(), 'logs', 'audit');
    const logFile = path.join(logDir, `audit_${new Date().toISOString().split('T')[0]}.json`);
    
    try {
      // Ensure log directory exists
      await fs.mkdir(logDir, { recursive: true });
      
      // Append events to log file
      const logEntry = {
        timestamp: new Date().toISOString(),
        events: events.map(event => ({
          ...event,
          _loggedAt: new Date().toISOString()
        }))
      };
      
      await fs.appendFile(logFile, `${JSON.stringify(logEntry)}\n`);
    } catch (error) {
      console.error('[Audit Scribe] Error writing to file:', error);
    }
  }

  // Write events to database (placeholder)
  private async writeToDatabase(_events: AuditEvent[]): Promise<void> {
    // TODO: Implement database storage
    // eslint-disable-next-line no-console
    console.log('[Audit Scribe] Database storage not yet implemented');
  }

  // Write events to external service (placeholder)
  private async writeToExternal(_events: AuditEvent[]): Promise<void> {
    // TODO: Implement external service integration
    // eslint-disable-next-line no-console
    console.log('[Audit Scribe] External service integration not yet implemented');
  }

  // Get audit events (for monitoring)
  public getEvents(filter?: Partial<AuditEvent>): AuditEvent[] {
    return this.eventQueue.filter(event => {
      if (!filter) return true;
      
      return Object.entries(filter).every(([key, value]) => {
        return event[key as keyof AuditEvent] === value;
      });
    });
  }

  // Get audit statistics
  public getStats(): Record<string, unknown> {
    const now = Date.now();
    const oneHourAgo = now - (60 * 60 * 1000);
    const oneDayAgo = now - (24 * 60 * 60 * 1000);
    
    const recentEvents = this.eventQueue.filter(event => 
      new Date(event.timestamp).getTime() > oneHourAgo
    );
    
    const dailyEvents = this.eventQueue.filter(event => 
      new Date(event.timestamp).getTime() > oneDayAgo
    );
    
    return {
      totalEvents: this.eventQueue.length,
      recentEvents: recentEvents.length,
      dailyEvents: dailyEvents.length,
      eventsByType: this.groupEventsByType(this.eventQueue),
      eventsBySeverity: this.groupEventsBySeverity(this.eventQueue),
      eventsByOutcome: this.groupEventsByOutcome(this.eventQueue)
    };
  }

  // Group events by type
  private groupEventsByType(events: AuditEvent[]): Record<string, number> {
    return events.reduce((acc, event) => {
      acc[event.eventType] = (acc[event.eventType] ?? 0) + 1;
      return acc;
    }, {} as Record<string, number>);
  }

  // Group events by severity
  private groupEventsBySeverity(events: AuditEvent[]): Record<string, number> {
    return events.reduce((acc, event) => {
      acc[event.severity] = (acc[event.severity] ?? 0) + 1;
      return acc;
    }, {} as Record<string, number>);
  }

  // Group events by outcome
  private groupEventsByOutcome(events: AuditEvent[]): Record<string, number> {
    return events.reduce((acc, event) => {
      acc[event.outcome] = (acc[event.outcome] ?? 0) + 1;
      return acc;
    }, {} as Record<string, number>);
  }

  // Cleanup old events
  public cleanup(): void {
    const retentionMs = this.config.retentionDays * 24 * 60 * 60 * 1000;
    const cutoffTime = Date.now() - retentionMs;
    
    this.eventQueue = this.eventQueue.filter(event => 
      new Date(event.timestamp).getTime() > cutoffTime
    );
  }
}

// Export singleton instance
export const auditLogger = new AuditLogger();

// Export middleware for easy integration
export function withAuditLog(handler: (req: NextRequest) => Promise<NextResponse>) {
  return async (req: NextRequest) => {
    // Log request
    const correlationId = auditLogger.logApiRequest(req);
    
    try {
      // Execute handler
      const response = await handler(req);
      
      // Log successful response
      auditLogger.logApiResponse(correlationId, response, 'success');
      
      // Add correlation ID to response headers
      response.headers.set('X-Correlation-ID', correlationId);
      
      return response;
    } catch (error) {
      // Log error response
      const errorResponse = NextResponse.json(
        { ok: false, error: 'Internal server error' },
        { status: 500 }
      );
      
      auditLogger.logApiResponse(correlationId, errorResponse, 'failure', error instanceof Error ? error.message : 'Unknown error');
      errorResponse.headers.set('X-Correlation-ID', correlationId);
      
      return errorResponse;
    }
  };
}
