/**
 * Load Champion - Performance Monitoring & Caching System
 * Generated by Hero System
 * 
 * Comprehensive performance monitoring, caching, and optimization
 * Improves system efficiency and addresses performance bottlenecks
 * 
 * Generated at: 2025-01-27
 */

import { NextRequest, NextResponse } from 'next/server';

// Performance metrics interface
export interface PerformanceMetrics {
  endpoint: string;
  method: string;
  responseTime: number;
  statusCode: number;
  timestamp: string;
  userId?: string;
  cacheHit?: boolean;
  databaseQueries?: number;
  memoryUsage?: number;
  cpuUsage?: number;
  errorCount?: number;
  successCount?: number;
}

// Cache configuration
export interface CacheConfig {
  enabled: boolean;
  ttl: number; // Time to live in milliseconds
  maxSize: number; // Maximum number of cached items
  strategy: 'lru' | 'fifo' | 'ttl';
  compression: boolean;
  encryption: boolean;
}

// Default cache configuration
const DEFAULT_CACHE_CONFIG: CacheConfig = {
  enabled: true,
  ttl: 5 * 60 * 1000, // 5 minutes
  maxSize: 1000,
  strategy: 'lru',
  compression: true,
  encryption: false
};

// Cache item interface
interface CacheItem<T = unknown> {
  key: string;
  value: T;
  timestamp: number;
  ttl: number;
  accessCount: number;
  lastAccessed: number;
}

// Performance Monitor Class
export class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = [];
  private cache: Map<string, CacheItem> = new Map();
  private config: CacheConfig;
  private isMonitoring = false;
  private startTime = Date.now();

  constructor(config: Partial<CacheConfig> = {}) {
    this.config = { ...DEFAULT_CACHE_CONFIG, ...config };
    this.startup();
  }

  // Initialize the performance monitor
  private startup() {
    if (this.config.enabled) {
      // eslint-disable-next-line no-console
      console.log('[Load Champion] Initialized with configuration:', this.config);
      
      // Start monitoring
      this.startMonitoring();
      
      // Start cache cleanup
      setInterval(() => this.cleanupCache(), 60000); // Every minute
      
      // Start metrics aggregation
      setInterval(() => this.aggregateMetrics(), 300000); // Every 5 minutes
    }
  }

  // Start performance monitoring
  private startMonitoring() {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    
    // Monitor memory usage
    setInterval(() => {
      if (typeof process !== 'undefined' && process.memoryUsage) {
        const memUsage = process.memoryUsage();
        this.recordMemoryUsage(memUsage);
      }
    }, 30000); // Every 30 seconds
    
    // Monitor CPU usage (if available)
    if (typeof process !== 'undefined' && process.cpuUsage) {
      setInterval(() => {
        const cpuUsage = process.cpuUsage();
        this.recordCpuUsage(cpuUsage);
      }, 60000); // Every minute
    }
  }

  // Record API performance metrics
  public recordApiMetrics(metrics: Partial<PerformanceMetrics>): void {
    const fullMetrics: PerformanceMetrics = {
      endpoint: metrics.endpoint ?? 'unknown',
      method: metrics.method ?? 'GET',
      responseTime: metrics.responseTime ?? 0,
      statusCode: metrics.statusCode ?? 200,
      timestamp: new Date().toISOString(),
      userId: metrics.userId,
      cacheHit: metrics.cacheHit ?? false,
      databaseQueries: metrics.databaseQueries ?? 0,
      errorCount: metrics.statusCode && metrics.statusCode >= 400 ? 1 : 0,
      successCount: metrics.statusCode && metrics.statusCode < 400 ? 1 : 0,
      ...metrics
    };
    
    this.metrics.push(fullMetrics);
    
    // Keep only last 10,000 metrics to prevent memory issues
    if (this.metrics.length > 10000) {
      this.metrics = this.metrics.slice(-5000);
    }
  }

  // Record memory usage
  private recordMemoryUsage(memUsage: NodeJS.MemoryUsage): void {
    this.metrics.push({
      endpoint: 'system',
      method: 'MONITOR',
      responseTime: 0,
      statusCode: 200,
      timestamp: new Date().toISOString(),
      memoryUsage: memUsage.heapUsed,
      cacheHit: false,
      databaseQueries: 0,
      errorCount: 0,
      successCount: 1
    });
  }

  // Record CPU usage
  private recordCpuUsage(cpuUsage: NodeJS.CpuUsage): void {
    this.metrics.push({
      endpoint: 'system',
      method: 'MONITOR',
      responseTime: 0,
      statusCode: 200,
      timestamp: new Date().toISOString(),
      cpuUsage: cpuUsage.user + cpuUsage.system,
      cacheHit: false,
      databaseQueries: 0,
      errorCount: 0,
      successCount: 1
    });
  }

  // Cache operations
  public setCache<T>(key: string, value: T, ttl?: number): void {
    if (!this.config.enabled) return;
    
    const item: CacheItem<T> = {
      key,
      value,
      timestamp: Date.now(),
      ttl: ttl ?? this.config.ttl,
      accessCount: 0,
      lastAccessed: Date.now()
    };
    
    // Implement LRU strategy
    if (this.config.strategy === 'lru' && this.cache.size >= this.config.maxSize) {
      this.evictLRU();
    }
    
    this.cache.set(key, item);
  }

  public getCache<T>(key: string): T | null {
    if (!this.config.enabled) return null;
    
    const item = this.cache.get(key);
    if (!item) return null;
    
    // Check if expired
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    // Update access statistics
    item.accessCount++;
    item.lastAccessed = Date.now();
    
    return item.value as T;
  }

  public deleteCache(key: string): boolean {
    return this.cache.delete(key);
  }

  public clearCache(): void {
    this.cache.clear();
  }

  // Cache eviction strategies
  private evictLRU(): void {
    let oldestKey = '';
    let oldestTime = Date.now();
    
    for (const [key, item] of this.cache.entries()) {
      if (item.lastAccessed < oldestTime) {
        oldestTime = item.lastAccessed;
        oldestKey = key;
      }
    }
    
    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  private evictFIFO(): void {
    let oldestKey = '';
    let oldestTime = Date.now();
    
    for (const [key, item] of this.cache.entries()) {
      if (item.timestamp < oldestTime) {
        oldestTime = item.timestamp;
        oldestKey = key;
      }
    }
    
    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  // Cache cleanup
  private cleanupCache(): void {
    const now = Date.now();
    
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.ttl) {
        this.cache.delete(key);
      }
    }
  }

  // Metrics aggregation
  private aggregateMetrics(): void {
    if (this.metrics.length === 0) return;
    
    const now = Date.now();
    const oneHourAgo = now - (60 * 60 * 1000);
    
    // Filter recent metrics
    const recentMetrics = this.metrics.filter(m => 
      new Date(m.timestamp).getTime() > oneHourAgo
    );
    
    if (recentMetrics.length === 0) return;
    
    // Calculate averages
    const avgResponseTime = recentMetrics.reduce((sum, m) => sum + m.responseTime, 0) / recentMetrics.length;
    const totalRequests = recentMetrics.length;
    const errorRate = recentMetrics.filter(m => m.statusCode >= 400).length / totalRequests;
    const cacheHitRate = recentMetrics.filter(m => m.cacheHit).length / totalRequests;
    
    // Log performance summary
    // eslint-disable-next-line no-console
    console.log('[Load Champion] Performance Summary (Last Hour):');
    // eslint-disable-next-line no-console
    console.log(`  Total Requests: ${totalRequests}`);
    // eslint-disable-next-line no-console
    console.log(`  Avg Response Time: ${avgResponseTime.toFixed(2)}ms`);
    // eslint-disable-next-line no-console
    console.log(`  Error Rate: ${(errorRate * 100).toFixed(2)}%`);
    // eslint-disable-next-line no-console
    console.log(`  Cache Hit Rate: ${(cacheHitRate * 100).toFixed(2)}%`);
    // eslint-disable-next-line no-console
    console.log(`  Active Cache Items: ${this.cache.size}`);
    
    // Alert on performance issues
    if (avgResponseTime > 1000) {
      // eslint-disable-next-line no-console
      console.warn('[Load Champion] WARNING: High response time detected!');
    }
    
    if (errorRate > 0.05) {
      // eslint-disable-next-line no-console
      console.warn('[Load Champion] WARNING: High error rate detected!');
    }
    
    if (cacheHitRate < 0.3) {
      // eslint-disable-next-line no-console
      console.warn('[Load Champion] WARNING: Low cache hit rate detected!');
    }
  }

  // Get performance statistics
  public getStats(): Record<string, unknown> {
    const now = Date.now();
    const oneHourAgo = now - (60 * 60 * 1000);
    const oneDayAgo = now - (24 * 60 * 60 * 1000);
    
    const hourlyMetrics = this.metrics.filter(m => 
      new Date(m.timestamp).getTime() > oneHourAgo
    );
    
    const dailyMetrics = this.metrics.filter(m => 
      new Date(m.timestamp).getTime() > oneDayAgo
    );
    
    const avgResponseTime = hourlyMetrics.length > 0 
      ? hourlyMetrics.reduce((sum, m) => sum + m.responseTime, 0) / hourlyMetrics.length 
      : 0;
    
    return {
      uptime: now - this.startTime,
      totalMetrics: this.metrics.length,
      hourlyMetrics: hourlyMetrics.length,
      dailyMetrics: dailyMetrics.length,
      avgResponseTime: Math.round(avgResponseTime),
      cacheSize: this.cache.size,
      cacheHitRate: hourlyMetrics.length > 0 
        ? hourlyMetrics.filter(m => m.cacheHit).length / hourlyMetrics.length 
        : 0,
      errorRate: hourlyMetrics.length > 0 
        ? hourlyMetrics.filter(m => m.statusCode >= 400).length / hourlyMetrics.length 
        : 0,
      topEndpoints: this.getTopEndpoints(hourlyMetrics),
      performanceTrends: this.getPerformanceTrends()
    };
  }

  // Get top endpoints by request count
  private getTopEndpoints(metrics: PerformanceMetrics[]): Array<{ endpoint: string; count: number; avgTime: number }> {
    const endpointStats = new Map<string, { count: number; totalTime: number }>();
    
    metrics.forEach(m => {
      if (m.endpoint === 'system') return;
      
      const current = endpointStats.get(m.endpoint) ?? { count: 0, totalTime: 0 };
      current.count++;
      current.totalTime += m.responseTime;
      endpointStats.set(m.endpoint, current);
    });
    
    return Array.from(endpointStats.entries())
      .map(([endpoint, stats]) => ({
        endpoint,
        count: stats.count,
        avgTime: Math.round(stats.totalTime / stats.count)
      }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
  }

  // Get performance trends
  private getPerformanceTrends(): Record<string, unknown> {
    const now = Date.now();
    const intervals = [
      { name: '5min', time: now - (5 * 60 * 1000) },
      { name: '15min', time: now - (15 * 60 * 1000) },
      { name: '1hour', time: now - (60 * 60 * 1000) }
    ];
    
    const trends: Record<string, unknown> = {};
    
    intervals.forEach(interval => {
      const metrics = this.metrics.filter(m => 
        new Date(m.timestamp).getTime() > interval.time
      );
      
      if (metrics.length > 0) {
        trends[interval.name] = {
          count: metrics.length,
          avgResponseTime: Math.round(
            metrics.reduce((sum, m) => sum + m.responseTime, 0) / metrics.length
          ),
          errorRate: metrics.filter(m => m.statusCode >= 400).length / metrics.length
        };
      }
    });
    
    return trends;
  }

  // Export metrics for external monitoring
  public exportMetrics(): PerformanceMetrics[] {
    return [...this.metrics];
  }

  // Clear old metrics
  public clearOldMetrics(olderThanDays: number = 7): void {
    const cutoffTime = Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);
    this.metrics = this.metrics.filter(m => 
      new Date(m.timestamp).getTime() > cutoffTime
    );
  }
}

// Export singleton instance
export const performanceMonitor = new PerformanceMonitor();

// Export middleware for easy integration
export function withPerformanceMonitoring(handler: (req: NextRequest) => Promise<NextResponse>) {
  return async (req: NextRequest) => {
    const startTime = Date.now();
    const endpoint = req.nextUrl.pathname;
    const method = req.method;
    
    try {
      // Execute handler
      const response = await handler(req);
      
      // Record performance metrics
      const responseTime = Date.now() - startTime;
      performanceMonitor.recordApiMetrics({
        endpoint,
        method,
        responseTime,
        statusCode: response.status,
        cacheHit: response.headers.get('X-Cache-Hit') === 'true'
      });
      
      return response;
    } catch (error) {
      // Record error metrics
      const responseTime = Date.now() - startTime;
      performanceMonitor.recordApiMetrics({
        endpoint,
        method,
        responseTime,
        statusCode: 500,
        errorCount: 1
      });
      
      throw error;
    }
  };
}

// Export cache wrapper for easy use
export function withCache<T>(
  key: string, 
  ttl?: number
): (fn: () => Promise<T>) => () => Promise<T> {
  return (fn: () => Promise<T>) => async (): Promise<T> => {
    // Try to get from cache first
    const cached = performanceMonitor.getCache<T>(key);
    if (cached !== null) {
      return cached;
    }
    
    // Execute function and cache result
    const result = await fn();
    performanceMonitor.setCache(key, result, ttl);
    return result;
  };
}
