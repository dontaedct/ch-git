/**
 * Enhanced Rate Limiter Paladin
 * Generated by Hero System
 * 
 * Comprehensive rate limiting for all API endpoints with intelligent throttling
 * Addresses Brute-Force Hydra threat and improves system security
 * 
 * Generated at: [RELATIVE: 7 months from now]
 */

import { NextRequest, NextResponse } from 'next/server';

// Rate limiting configuration
const RATE_LIMIT_CONFIG = {
  // General API endpoints
  default: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 100, // 100 requests per window
    skipSuccessfulRequests: false,
    skipFailedRequests: false,
  },
  
  // Authentication endpoints (more restrictive)
  auth: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 5, // 5 attempts per window
    skipSuccessfulRequests: true,
    skipFailedRequests: false,
  },
  
  // Progress metrics (moderate)
  progress: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 50, // 50 requests per window
    skipSuccessfulRequests: false,
    skipFailedRequests: false,
  },
  
  // Weekly plans (moderate)
  weeklyPlans: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 30, // 30 requests per window
    skipSuccessfulRequests: false,
    skipFailedRequests: false,
  },
  
  // Client operations (moderate)
  clients: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 40, // 40 requests per window
    skipSuccessfulRequests: false,
    skipFailedRequests: false,
  },
  
  // Intake operations (moderate)
  intake: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 20, // 20 requests per window
    skipSuccessfulRequests: false,
    skipFailedRequests: false,
  },
  
  // Trainer profile (moderate)
  trainerProfile: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 25, // 25 requests per window
    skipSuccessfulRequests: false,
    skipFailedRequests: false,
  }
};

// In-memory store for rate limiting (in production, use Redis)
const rateLimitStore = new Map<string, { count: number; resetTime: number }>();

// Clean up expired entries every 5 minutes
setInterval(() => {
  const now = Date.now();
  for (const [key, value] of rateLimitStore.entries()) {
    if (now > value.resetTime) {
      rateLimitStore.delete(key);
    }
  }
}, 5 * 60 * 1000);

// Get client identifier from request
function getClientIdentifier(req: NextRequest): string {
  const forwarded = req.headers.get('x-forwarded-for');
  const realIp = req.headers.get('x-real-ip');
  const cfConnectingIp = req.headers.get('cf-connecting-ip');
  
  // Extended NextRequest interface for IP access
  interface ExtendedRequest extends NextRequest {
    ip?: string;
  }
  
  let clientIp = (req as ExtendedRequest).ip ?? 'unknown';
  
  if (forwarded) {
    clientIp = forwarded.split(',')[0].trim();
  } else if (realIp) {
    clientIp = realIp;
  } else if (cfConnectingIp) {
    clientIp = cfConnectingIp;
  }
  
  // Add user agent for additional uniqueness
  const userAgent = req.headers.get('user-agent') ?? 'unknown';
  return `${clientIp}:${userAgent}`;
}

// Get rate limit configuration for endpoint
function getRateLimitConfig(endpoint: string) {
  if (endpoint.includes('/auth')) return RATE_LIMIT_CONFIG.auth;
  if (endpoint.includes('/progress-metrics')) return RATE_LIMIT_CONFIG.progress;
  if (endpoint.includes('/weekly-plans')) return RATE_LIMIT_CONFIG.weeklyPlans;
  if (endpoint.includes('/clients')) return RATE_LIMIT_CONFIG.clients;
  if (endpoint.includes('/intake')) return RATE_LIMIT_CONFIG.intake;
  if (endpoint.includes('/trainer-profile')) return RATE_LIMIT_CONFIG.trainerProfile;
  
  return RATE_LIMIT_CONFIG.default;
}

// Check rate limit
function checkRateLimit(clientId: string, endpoint: string): { allowed: boolean; remaining: number; resetTime: number } {
  const config = getRateLimitConfig(endpoint);
  const key = `${clientId}:${endpoint}`;
  const now = Date.now();
  
  // Get current rate limit data
  const current = rateLimitStore.get(key);
  
  if (!current || now > current.resetTime) {
    // First request or window expired
    rateLimitStore.set(key, {
      count: 1,
      resetTime: now + config.windowMs
    });
    
    return {
      allowed: true,
      remaining: config.maxRequests - 1,
      resetTime: now + config.windowMs
    };
  }
  
  // Check if within limit
  if (current.count >= config.maxRequests) {
    return {
      allowed: false,
      remaining: 0,
      resetTime: current.resetTime
    };
  }
  
  // Increment counter
  current.count++;
  rateLimitStore.set(key, current);
  
  return {
    allowed: true,
    remaining: config.maxRequests - current.count,
    resetTime: current.resetTime
  };
}

// Rate limiting middleware
export function withRateLimit(handler: (req: NextRequest) => Promise<NextResponse>) {
  return async (req: NextRequest) => {
    const clientId = getClientIdentifier(req);
    const endpoint = req.nextUrl.pathname;
    
    // Check rate limit
    const rateLimit = checkRateLimit(clientId, endpoint);
    
    if (!rateLimit.allowed) {
      // Rate limit exceeded
      const retryAfter = Math.ceil((rateLimit.resetTime - Date.now()) / 1000);
      
      return NextResponse.json(
        {
          ok: false,
          error: 'Rate limit exceeded',
          retryAfter,
          resetTime: new Date(rateLimit.resetTime).toISOString()
        },
        {
          status: 429,
          headers: {
            'X-RateLimit-Limit': getRateLimitConfig(endpoint).maxRequests.toString(),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': new Date(rateLimit.resetTime).toISOString(),
            'Retry-After': retryAfter.toString()
          }
        }
      );
    }
    
    // Add rate limit headers to response
    const response = await handler(req);
    
    response.headers.set('X-RateLimit-Limit', getRateLimitConfig(endpoint).maxRequests.toString());
    response.headers.set('X-RateLimit-Remaining', rateLimit.remaining.toString());
    response.headers.set('X-RateLimit-Reset', new Date(rateLimit.resetTime).toISOString());
    
    return response;
  };
}

// Export rate limit configuration for monitoring
export { RATE_LIMIT_CONFIG, rateLimitStore };

// Log rate limit events for monitoring
export function logRateLimitEvent(clientId: string, endpoint: string, action: 'allowed' | 'blocked') {
  if (process.env.NODE_ENV === 'development') {
    // eslint-disable-next-line no-console
    console.log(`[Rate Limiter] ${action.toUpperCase()}: ${clientId} -> ${endpoint}`);
  }
  
  // In production, send to monitoring system
  // TODO: Integrate with Sentry or other monitoring
}
