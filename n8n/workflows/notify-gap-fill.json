{
  "name": "Notify-10 Gap Fill",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "notify-gap-fill",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "notify-gap-fill-webhook"
    },
    {
      "parameters": {
        "functionCode": "// n8n Reliability Wrapper\n// This node implements reliability controls for the workflow\n\nconst tenantId = $input.first().json.tenant_id || 'default-tenant';\nconst workflowName = 'notify-gap-fill';\nconst payload = $input.first().json;\n\n// Check if content has changed (skip if no changes)\nconst hasContentChanges = $input.first().json.has_content_changes !== false;\n\nif (!hasContentChanges) {\n  return {\n    json: {\n      status: 'skipped',\n      reason: 'No content changes detected',\n      tenant_id: tenantId,\n      timestamp: new Date().toISOString()\n    }\n  };\n}\n\n// Prepare reliability context\nconst reliabilityContext = {\n  tenant_id: tenantId,\n  workflow_name: workflowName,\n  payload: payload,\n  timestamp: new Date().toISOString(),\n  reliability_controls: {\n    backoff_enabled: true,\n    circuit_breaker_enabled: true,\n    concurrency_limit_enabled: true,\n    dlq_enabled: true\n  }\n};\n\nreturn {\n  json: reliabilityContext\n};"
      },
      "id": "reliability-wrapper",
      "name": "Reliability Wrapper",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "skip-condition",
              "leftValue": "={{ $json.status }}",
              "rightValue": "skipped",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "skip-check",
      "name": "Skip Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "functionCode": "// Get client data with gap analysis\n// This simulates the business logic for gap fill notifications\n\nconst tenantId = $input.first().json.tenant_id;\nconst clients = $input.first().json.clients || [];\n\n// Simulate gap analysis\nconst clientsWithGaps = clients.filter(client => {\n  // Mock gap detection logic\n  const lastCheckin = new Date(client.last_checkin || '2025-01-01');\n  const daysSinceCheckin = (Date.now() - lastCheckin.getTime()) / (1000 * 60 * 60 * 24);\n  return daysSinceCheckin > 10; // Gap if no checkin for 10+ days\n});\n\n// Prepare notification data\nconst notifications = clientsWithGaps.map(client => ({\n  client_id: client.id,\n  client_name: client.name,\n  client_email: client.email,\n  gap_days: Math.floor((Date.now() - new Date(client.last_checkin).getTime()) / (1000 * 60 * 60 * 24)),\n  message_template: 'gap_fill_reminder',\n  priority: 'medium'\n}));\n\nreturn {\n  json: {\n    tenant_id: tenantId,\n    workflow_name: 'notify-gap-fill',\n    notifications: notifications,\n    total_clients: clients.length,\n    clients_with_gaps: clientsWithGaps.length,\n    processed_at: new Date().toISOString()\n  }\n};"
      },
      "id": "gap-analysis",
      "name": "Gap Analysis",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [900, 200]
    },
    {
      "parameters": {
        "functionCode": "// Send notifications with retry logic\n// This simulates sending notifications to clients\n\nconst data = $input.first().json;\nconst notifications = data.notifications || [];\nconst tenantId = data.tenant_id;\n\n// Simulate notification sending with potential failures\nconst results = [];\n\nfor (const notification of notifications) {\n  try {\n    // Mock notification service call\n    const success = Math.random() > 0.1; // 90% success rate\n    \n    if (success) {\n      results.push({\n        client_id: notification.client_id,\n        status: 'sent',\n        message_id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        sent_at: new Date().toISOString()\n      });\n    } else {\n      throw new Error(`Failed to send notification to ${notification.client_email}`);\n    }\n  } catch (error) {\n    results.push({\n      client_id: notification.client_id,\n      status: 'failed',\n      error: error.message,\n      failed_at: new Date().toISOString()\n    });\n  }\n}\n\nconst successCount = results.filter(r => r.status === 'sent').length;\nconst failureCount = results.filter(r => r.status === 'failed').length;\n\nreturn {\n  json: {\n    tenant_id: tenantId,\n    workflow_name: 'notify-gap-fill',\n    results: results,\n    summary: {\n      total_notifications: notifications.length,\n      successful: successCount,\n      failed: failureCount,\n      success_rate: notifications.length > 0 ? (successCount / notifications.length) * 100 : 0\n    },\n    completed_at: new Date().toISOString()\n  }\n};"
      },
      "id": "send-notifications",
      "name": "Send Notifications",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 200]
    },
    {
      "parameters": {
        "functionCode": "// Handle failures and add to DLQ if needed\nconst data = $input.first().json;\nconst failedNotifications = data.results.filter(r => r.status === 'failed');\n\nif (failedNotifications.length > 0) {\n  // Add failed notifications to DLQ\n  const dlqEntries = failedNotifications.map(notification => ({\n    tenant_id: data.tenant_id,\n    workflow_name: data.workflow_name,\n    payload: notification,\n    error_message: notification.error,\n    error_code: 'NOTIFICATION_FAILED',\n    retry_count: 0,\n    expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() // 24 hours\n  }));\n  \n  console.log(`Adding ${dlqEntries.length} failed notifications to DLQ`);\n}\n\nreturn {\n  json: {\n    ...data,\n    dlq_entries: failedNotifications.length,\n    final_status: failedNotifications.length > 0 ? 'partial_success' : 'success'\n  }\n};"
      },
      "id": "handle-failures",
      "name": "Handle Failures",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "skip-response",
      "name": "Skip Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [900, 400]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Reliability Wrapper",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reliability Wrapper": {
      "main": [
        [
          {
            "node": "Skip Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Check": {
      "main": [
        [
          {
            "node": "Gap Analysis",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gap Analysis": {
      "main": [
        [
          {
            "node": "Send Notifications",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Notifications": {
      "main": [
        [
          {
            "node": "Handle Failures",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Failures": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-08-25T00:00:00.000Z",
      "updatedAt": "2025-08-25T00:00:00.000Z",
      "id": "reliability",
      "name": "reliability"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-08-25T00:00:00.000Z",
  "versionId": "1"
}
