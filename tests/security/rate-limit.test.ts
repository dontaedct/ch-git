/**
 * Enhanced Rate Limiting Tests
 * 
 * Tests for enhanced rate limiting with bot detection, adaptive limits,
 * burst protection, and security event logging.
 */

import {\n  checkRateLimit,\n  getRateLimitConfigForRoute,\n  getRateLimitStats,\n  cleanupExpiredEntries,\n  clearRateLimit,\n  blockIP,\n  unblockIP,\n  isIPBlocked,\n  getBlockedIPs,\n  RATE_LIMITS\n} from '../../lib/rate-limit';\n\ndescribe('Enhanced Rate Limiting', () => {\n  beforeEach(() => {\n    // Clear all rate limit entries before each test\n    const stats = getRateLimitStats();\n    stats.entries.forEach(entry => {\n      const tenantId = entry.key.split(':')[0];\n      clearRateLimit(tenantId);\n    });\n  });\n\n  describe('Basic Rate Limiting', () => {\n    it('should allow requests within limit', () => {\n      const config = RATE_LIMITS.GENERAL_API;\n      const result1 = checkRateLimit('tenant1', config, {\n        ip: '203.0.113.1',\n        userAgent: 'Mozilla/5.0'\n      });\n      \n      expect(result1.allowed).toBe(true);\n      expect(result1.remaining).toBe(config.maxRequests - 1);\n      expect(result1.riskLevel).toBe('low');\n      expect(result1.isBot).toBe(false);\n    });\n    \n    it('should block requests exceeding limit', () => {\n      const config = { windowMs: 60000, maxRequests: 2 };\n      \n      // First two requests should pass\n      const result1 = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      const result2 = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      \n      expect(result1.allowed).toBe(true);\n      expect(result2.allowed).toBe(true);\n      expect(result2.remaining).toBe(0);\n      \n      // Third request should be blocked\n      const result3 = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      \n      expect(result3.allowed).toBe(false);\n      expect(result3.remaining).toBe(0);\n      expect(result3.retryAfter).toBeGreaterThan(0);\n      expect(result3.blockReason).toBe('rate_limit_exceeded');\n    });\n    \n    it('should reset window after expiry', async () => {\n      const config = { windowMs: 100, maxRequests: 1 }; // 100ms window\n      \n      // First request should pass\n      const result1 = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      expect(result1.allowed).toBe(true);\n      \n      // Second request should be blocked\n      const result2 = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      expect(result2.allowed).toBe(false);\n      \n      // Wait for window to expire\n      await new Promise(resolve => setTimeout(resolve, 150));\n      \n      // Third request should pass (new window)\n      const result3 = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      expect(result3.allowed).toBe(true);\n    });\n  });\n\n  describe('Bot Detection and Adaptive Limits', () => {\n    it('should apply stricter limits for bots', () => {\n      const config = RATE_LIMITS.GENERAL_API; // 100 requests, 0.5 bot multiplier = 50 for bots\n      \n      // Regular user gets full limit\n      const humanResult = checkRateLimit('tenant1', config, {\n        ip: '203.0.113.1',\n        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n        isBot: false\n      });\n      \n      expect(humanResult.allowed).toBe(true);\n      expect(humanResult.remaining).toBe(99); // Full limit - 1\n      \n      // Bot gets reduced limit\n      const botResult = checkRateLimit('tenant2', config, {\n        ip: '203.0.113.2',\n        userAgent: 'Googlebot/2.1',\n        isBot: true\n      });\n      \n      expect(botResult.allowed).toBe(true);\n      expect(botResult.remaining).toBe(49); // 50 (bot limit) - 1\n      expect(botResult.isBot).toBe(true);\n    });\n    \n    it('should detect bots from user agent', () => {\n      const config = RATE_LIMITS.GENERAL_API;\n      \n      const result = checkRateLimit('tenant1', config, {\n        ip: '203.0.113.1',\n        userAgent: 'curl/7.68.0' // Bot user agent\n      });\n      \n      expect(result.isBot).toBe(true);\n      expect(result.riskLevel).toBe('medium');\n    });\n    \n    it('should increase risk level for admin routes', () => {\n      const config = RATE_LIMITS.ADMIN_API;\n      \n      const result = checkRateLimit('tenant1', config, {\n        ip: '203.0.113.1',\n        userAgent: 'curl/7.68.0',\n        isBot: true,\n        route: '/api/admin/users'\n      });\n      \n      expect(result.riskLevel).toBe('high'); // Bot + admin route\n    });\n  });\n\n  describe('Burst Protection', () => {\n    it('should implement burst protection', () => {\n      const config = {\n        windowMs: 60000,\n        maxRequests: 100,\n        burstWindowMs: 1000, // 1 second burst window\n        burstMaxRequests: 5   // Max 5 requests in 1 second\n      };\n      \n      // First 5 requests should pass\n      for (let i = 0; i < 5; i++) {\n        const result = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n        expect(result.allowed).toBe(true);\n      }\n      \n      // 6th request should be blocked due to burst limit\n      const result = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      expect(result.allowed).toBe(false);\n      expect(result.blockReason).toBe('burst_limit_exceeded');\n    });\n    \n    it('should apply bot multiplier to burst limits', () => {\n      const config = {\n        windowMs: 60000,\n        maxRequests: 100,\n        burstWindowMs: 1000,\n        burstMaxRequests: 6,   // 6 for humans\n        botMultiplier: 0.5     // 3 for bots\n      };\n      \n      // Bot should be limited to 3 requests in burst window\n      for (let i = 0; i < 3; i++) {\n        const result = checkRateLimit('tenant1', config, {\n          ip: '203.0.113.1',\n          isBot: true\n        });\n        expect(result.allowed).toBe(true);\n      }\n      \n      // 4th request should be blocked\n      const result = checkRateLimit('tenant1', config, {\n        ip: '203.0.113.1',\n        isBot: true\n      });\n      expect(result.allowed).toBe(false);\n      expect(result.blockReason).toBe('burst_limit_exceeded');\n    });\n  });\n\n  describe('Route-based Configuration', () => {\n    it('should return correct config for Guardian routes', () => {\n      const heartbeatConfig = getRateLimitConfigForRoute('/api/guardian/heartbeat');\n      expect(heartbeatConfig).toBe(RATE_LIMITS.GUARDIAN_HEARTBEAT);\n      \n      const backupConfig = getRateLimitConfigForRoute('/api/guardian/backup-intent');\n      expect(backupConfig).toBe(RATE_LIMITS.GUARDIAN_BACKUP_INTENT);\n    });\n    \n    it('should return correct config for admin routes', () => {\n      const config = getRateLimitConfigForRoute('/api/admin/users');\n      expect(config).toBe(RATE_LIMITS.ADMIN_API);\n    });\n    \n    it('should return correct config for webhook routes', () => {\n      const config = getRateLimitConfigForRoute('/api/webhooks/stripe');\n      expect(config).toBe(RATE_LIMITS.WEBHOOK_API);\n    });\n    \n    it('should return correct config for auth routes', () => {\n      const config = getRateLimitConfigForRoute('/api/auth/login');\n      expect(config).toBe(RATE_LIMITS.AUTH_API);\n      \n      const loginConfig = getRateLimitConfigForRoute('/login');\n      expect(loginConfig).toBe(RATE_LIMITS.AUTH_API);\n    });\n    \n    it('should return general config for other routes', () => {\n      const config = getRateLimitConfigForRoute('/api/health');\n      expect(config).toBe(RATE_LIMITS.GENERAL_API);\n    });\n  });\n\n  describe('Violation Tracking', () => {\n    it('should track violations', () => {\n      const config = { windowMs: 60000, maxRequests: 1 };\n      \n      // First request passes\n      const result1 = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      expect(result1.allowed).toBe(true);\n      expect(result1.violations).toBe(0);\n      \n      // Second request is blocked and creates violation\n      const result2 = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      expect(result2.allowed).toBe(false);\n      expect(result2.violations).toBe(1);\n      \n      // Third request increases violations\n      const result3 = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      expect(result3.allowed).toBe(false);\n      expect(result3.violations).toBe(2);\n    });\n    \n    it('should increase risk level with violations', () => {\n      const config = { windowMs: 60000, maxRequests: 1 };\n      \n      // Create violations\n      checkRateLimit('tenant1', config, { ip: '203.0.113.1' }); // Pass\n      \n      for (let i = 0; i < 7; i++) {\n        checkRateLimit('tenant1', config, { ip: '203.0.113.1' }); // Violations\n      }\n      \n      const result = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      expect(result.allowed).toBe(false);\n      expect(result.riskLevel).toBe('high'); // High violations\n    });\n  });\n\n  describe('Statistics and Monitoring', () => {\n    it('should provide comprehensive statistics', () => {\n      const config = RATE_LIMITS.GENERAL_API;\n      \n      // Create some entries\n      checkRateLimit('tenant1', config, {\n        ip: '203.0.113.1',\n        userAgent: 'Mozilla/5.0',\n        isBot: false\n      });\n      \n      checkRateLimit('tenant2', config, {\n        ip: '203.0.113.2',\n        userAgent: 'Googlebot/2.1',\n        isBot: true\n      });\n      \n      const stats = getRateLimitStats();\n      \n      expect(stats.totalEntries).toBeGreaterThan(0);\n      expect(stats.botCount).toBe(1);\n      expect(stats.entries.length).toBeGreaterThan(0);\n      \n      // Check entry structure\n      const entry = stats.entries[0];\n      expect(entry).toHaveProperty('key');\n      expect(entry).toHaveProperty('count');\n      expect(entry).toHaveProperty('resetTime');\n      expect(entry).toHaveProperty('violations');\n      expect(entry).toHaveProperty('isBot');\n      expect(entry).toHaveProperty('riskLevel');\n    });\n    \n    it('should track total violations', () => {\n      const config = { windowMs: 60000, maxRequests: 1 };\n      \n      // Create violations\n      checkRateLimit('tenant1', config, { ip: '203.0.113.1' }); // Pass\n      checkRateLimit('tenant1', config, { ip: '203.0.113.1' }); // Violation\n      checkRateLimit('tenant2', config, { ip: '203.0.113.2' }); // Pass\n      checkRateLimit('tenant2', config, { ip: '203.0.113.2' }); // Violation\n      \n      const stats = getRateLimitStats();\n      expect(stats.totalViolations).toBe(2);\n    });\n  });\n\n  describe('Cleanup and Maintenance', () => {\n    it('should clean up expired entries', async () => {\n      const config = { windowMs: 100, maxRequests: 1 };\n      \n      // Create entries\n      checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      checkRateLimit('tenant2', config, { ip: '203.0.113.2' });\n      \n      const statsBefore = getRateLimitStats();\n      expect(statsBefore.totalEntries).toBe(2);\n      \n      // Wait for expiry\n      await new Promise(resolve => setTimeout(resolve, 150));\n      \n      // Cleanup\n      const cleanup = cleanupExpiredEntries();\n      \n      expect(cleanup.deleted).toBe(2);\n      expect(cleanup.retained).toBe(0);\n      expect(cleanup.violatorsRetained).toBe(0);\n    });\n    \n    it('should retain violators longer', async () => {\n      const config = { windowMs: 100, maxRequests: 1 };\n      \n      // Create entry with violations\n      checkRateLimit('tenant1', config, { ip: '203.0.113.1' }); // Pass\n      checkRateLimit('tenant1', config, { ip: '203.0.113.1' }); // Violation\n      \n      // Wait for normal expiry but not violator expiry\n      await new Promise(resolve => setTimeout(resolve, 150));\n      \n      const cleanup = cleanupExpiredEntries();\n      \n      expect(cleanup.deleted).toBe(0);\n      expect(cleanup.violatorsRetained).toBe(1);\n    });\n    \n    it('should clear rate limit for specific tenant', () => {\n      const config = RATE_LIMITS.GENERAL_API;\n      \n      checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      checkRateLimit('tenant2', config, { ip: '203.0.113.2' });\n      \n      const statsBefore = getRateLimitStats();\n      expect(statsBefore.totalEntries).toBe(2);\n      \n      clearRateLimit('tenant1');\n      \n      const statsAfter = getRateLimitStats();\n      expect(statsAfter.totalEntries).toBe(1);\n    });\n  });\n\n  describe('IP Blocking', () => {\n    it('should block and unblock IPs', () => {\n      const ip = '198.51.100.1';\n      \n      expect(isIPBlocked(ip)).toBe(false);\n      \n      blockIP(ip, 'suspicious activity');\n      expect(isIPBlocked(ip)).toBe(true);\n      \n      const blockedList = getBlockedIPs();\n      expect(blockedList).toContain(ip);\n      \n      unblockIP(ip);\n      expect(isIPBlocked(ip)).toBe(false);\n    });\n    \n    it('should maintain list of blocked IPs', () => {\n      const ips = ['192.0.2.1', '192.0.2.2', '192.0.2.3'];\n      \n      ips.forEach(ip => blockIP(ip, 'test'));\n      \n      const blockedList = getBlockedIPs();\n      expect(blockedList).toHaveLength(3);\n      expect(blockedList).toEqual(expect.arrayContaining(ips));\n    });\n  });\n\n  describe('Edge Cases', () => {\n    it('should handle requests with no IP', () => {\n      const config = RATE_LIMITS.GENERAL_API;\n      \n      const result = checkRateLimit('tenant1', config, {\n        userAgent: 'Mozilla/5.0'\n      });\n      \n      expect(result.allowed).toBe(true);\n      expect(result.riskLevel).toBe('low');\n    });\n    \n    it('should handle requests with no user agent', () => {\n      const config = RATE_LIMITS.GENERAL_API;\n      \n      const result = checkRateLimit('tenant1', config, {\n        ip: '203.0.113.1'\n      });\n      \n      expect(result.allowed).toBe(true);\n      expect(result.isBot).toBe(false); // Not auto-detected as bot without UA\n    });\n    \n    it('should handle custom key generator', () => {\n      const config = {\n        windowMs: 60000,\n        maxRequests: 10,\n        keyGenerator: (tenantId: string, ip?: string) => `custom:${tenantId}:${ip}`\n      };\n      \n      const result = checkRateLimit('tenant1', config, { ip: '203.0.113.1' });\n      \n      expect(result.allowed).toBe(true);\n      \n      const stats = getRateLimitStats();\n      const entry = stats.entries.find(e => e.key.startsWith('custom:'));\n      expect(entry).toBeDefined();\n    });\n    \n    it('should handle very high request rates', () => {\n      const config = { windowMs: 60000, maxRequests: 1000 };\n      const results = [];\n      \n      // Make 1001 requests rapidly\n      for (let i = 0; i < 1001; i++) {\n        const result = checkRateLimit('tenant1', config, {\n          ip: '203.0.113.1',\n          userAgent: 'test-client'\n        });\n        results.push(result);\n      }\n      \n      const allowed = results.filter(r => r.allowed).length;\n      const blocked = results.filter(r => !r.allowed).length;\n      \n      expect(allowed).toBe(1000);\n      expect(blocked).toBe(1);\n    });\n  });\n});