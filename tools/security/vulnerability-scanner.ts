#!/usr/bin/env tsx

/**
 * Vulnerability Assessment Tool
 * 
 * Comprehensive vulnerability scanning and assessment for the DCT Micro-Apps template.
 * Integrates with Renovate and CI/CD pipeline for automated security monitoring.
 */

import { execSync } from 'child_process';
import { writeFileSync, readFileSync, existsSync } from 'fs';
import * as path from 'path';

interface VulnerabilityReport {
  timestamp: string;
  totalVulnerabilities: number;
  criticalCount: number;
  highCount: number;
  moderateCount: number;
  lowCount: number;
  affectedPackages: string[];
  recommendations: string[];
  riskScore: number;
  complianceStatus: 'PASS' | 'WARN' | 'FAIL';
}

interface PackageVulnerability {
  name: string;
  version: string;
  severity: 'critical' | 'high' | 'moderate' | 'low';
  cwe: string[];
  cvss: number;
  description: string;
  fixedIn?: string;
  patchAvailable: boolean;
}

class VulnerabilityScanner {
  private projectRoot: string;
  private outputDir: string;

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
    this.outputDir = path.join(projectRoot, 'docs', 'security', 'vulnerability-reports');
    this.ensureOutputDir();
  }

  private ensureOutputDir(): void {
    const docsDir = path.join(this.projectRoot, 'docs');
    const securityDir = path.join(docsDir, 'security');
    
    if (!existsSync(docsDir)) {
      execSync(`mkdir -p "${docsDir}"`);
    }
    
    if (!existsSync(securityDir)) {
      execSync(`mkdir -p "${securityDir}"`);
    }
    
    if (!existsSync(this.outputDir)) {
      execSync(`mkdir -p "${this.outputDir}"`);
    }
  }

  /**
   * Run comprehensive vulnerability assessment
   */
  async runAssessment(): Promise<VulnerabilityReport> {
    console.log('üîç Starting comprehensive vulnerability assessment...');
    
    const timestamp = new Date().toISOString();
    
    // Run npm audit
    const auditResults = await this.runNpmAudit();
    
    // Run Snyk scan (if available)
    const snykResults = await this.runSnykScan();
    
    // Analyze package.json for known vulnerable packages
    const packageAnalysis = await this.analyzePackageVulnerabilities();
    
    // Generate comprehensive report
    const report = this.generateReport({
      timestamp,
      auditResults,
      snykResults,
      packageAnalysis
    });
    
    // Save reports
    await this.saveReports(report);
    
    // Update security dashboard
    await this.updateSecurityDashboard(report);
    
    return report;
  }

  /**
   * Run npm audit and parse results
   */
  private async runNpmAudit(): Promise<any> {
    try {
      console.log('üì¶ Running npm audit...');
      
      const auditOutput = execSync('npm audit --json', { 
        cwd: this.projectRoot,
        encoding: 'utf8' 
      });
      
      return JSON.parse(auditOutput);
    } catch (error: any) {
      console.log('‚ö†Ô∏è npm audit found vulnerabilities');
      
      if (error.stdout) {
        try {
          return JSON.parse(error.stdout);
        } catch {
          return { vulnerabilities: {}, summary: { total: 0 } };
        }
      }
      
      return { vulnerabilities: {}, summary: { total: 0 } };
    }
  }

  /**
   * Run Snyk scan if available
   */
  private async runSnykScan(): Promise<any> {
    try {
      console.log('üõ°Ô∏è Running Snyk scan...');
      
      const snykOutput = execSync('npx snyk test --json', {
        cwd: this.projectRoot,
        encoding: 'utf8'
      });
      
      return JSON.parse(snykOutput);
    } catch (error) {
      console.log('‚ÑπÔ∏è Snyk not available or found issues');
      return null;
    }
  }

  /**
   * Analyze package.json for known vulnerable package patterns
   */
  private async analyzePackageVulnerabilities(): Promise<PackageVulnerability[]> {
    console.log('üî¨ Analyzing package vulnerabilities...');
    
    const vulnerabilities: PackageVulnerability[] = [];
    
    try {
      const packageJson = JSON.parse(
        readFileSync(path.join(this.projectRoot, 'package.json'), 'utf8')
      );
      
      const allDeps = {
        ...packageJson.dependencies || {},
        ...packageJson.devDependencies || {}
      };
      
      // Known vulnerable package patterns (this would typically come from a security database)
      const knownVulnerablePatterns = [
        { pattern: /^lodash@[^4]/, severity: 'high' as const, description: 'Lodash versions < 4.0.0 have prototype pollution vulnerabilities' },
        { pattern: /^axios@0\./, severity: 'moderate' as const, description: 'Axios 0.x versions have known security issues' },
        { pattern: /^express@[^4]/, severity: 'high' as const, description: 'Express < 4.0.0 has multiple security vulnerabilities' }
      ];
      
      for (const [packageName, version] of Object.entries(allDeps)) {
        const packageVersion = `${packageName}@${version}`;
        
        for (const vuln of knownVulnerablePatterns) {
          if (vuln.pattern.test(packageVersion)) {
            vulnerabilities.push({
              name: packageName,
              version: version as string,
              severity: vuln.severity,
              cwe: ['CWE-79', 'CWE-89'], // Example CWE codes
              cvss: this.calculateCVSS(vuln.severity),
              description: vuln.description,
              patchAvailable: true
            });
          }
        }
      }
      
    } catch (error) {
      console.error('Error analyzing package vulnerabilities:', error);
    }
    
    return vulnerabilities;
  }

  /**
   * Calculate CVSS score based on severity
   */
  private calculateCVSS(severity: string): number {
    switch (severity) {
      case 'critical': return 9.5;
      case 'high': return 7.5;
      case 'moderate': return 5.5;
      case 'low': return 2.5;
      default: return 0;
    }
  }

  /**
   * Generate comprehensive vulnerability report
   */
  private generateReport(data: any): VulnerabilityReport {
    console.log('üìä Generating vulnerability report...');
    
    const { timestamp, auditResults, packageAnalysis } = data;
    
    // Extract vulnerability counts from audit results
    const vulnerabilities = auditResults.vulnerabilities || {};
    const vulnEntries = Object.entries(vulnerabilities);
    
    const criticalCount = vulnEntries.filter(([_, vuln]: any) => vuln.severity === 'critical').length;
    const highCount = vulnEntries.filter(([_, vuln]: any) => vuln.severity === 'high').length;
    const moderateCount = vulnEntries.filter(([_, vuln]: any) => vuln.severity === 'moderate').length;
    const lowCount = vulnEntries.filter(([_, vuln]: any) => vuln.severity === 'low').length;
    
    const totalVulnerabilities = criticalCount + highCount + moderateCount + lowCount;
    const affectedPackages = vulnEntries.map(([name]: any) => name);
    
    // Calculate risk score (0-100)
    const riskScore = this.calculateRiskScore(criticalCount, highCount, moderateCount, lowCount);
    
    // Determine compliance status
    const complianceStatus = this.determineComplianceStatus(criticalCount, highCount, riskScore);
    
    // Generate recommendations
    const recommendations = this.generateRecommendations(criticalCount, highCount, moderateCount, affectedPackages);
    
    return {
      timestamp,
      totalVulnerabilities,
      criticalCount,
      highCount,
      moderateCount,
      lowCount,
      affectedPackages,
      recommendations,
      riskScore,
      complianceStatus
    };
  }

  /**
   * Calculate overall risk score
   */
  private calculateRiskScore(critical: number, high: number, moderate: number, low: number): number {
    return Math.min(100, (critical * 25) + (high * 10) + (moderate * 5) + (low * 1));
  }

  /**
   * Determine compliance status based on vulnerabilities
   */
  private determineComplianceStatus(critical: number, high: number, riskScore: number): 'PASS' | 'WARN' | 'FAIL' {
    if (critical > 0) return 'FAIL';
    if (high > 5 || riskScore > 50) return 'WARN';
    return 'PASS';
  }

  /**
   * Generate actionable recommendations
   */
  private generateRecommendations(critical: number, high: number, moderate: number, packages: string[]): string[] {
    const recommendations: string[] = [];
    
    if (critical > 0) {
      recommendations.push(`üö® URGENT: Address ${critical} critical vulnerabilities immediately`);
      recommendations.push('üîÑ Run `npm audit fix` to apply automatic fixes');
      recommendations.push('üìã Review and update affected packages manually if auto-fix fails');
    }
    
    if (high > 0) {
      recommendations.push(`üî¥ HIGH PRIORITY: Address ${high} high severity vulnerabilities within 48 hours`);
      recommendations.push('üîç Review security advisories for affected packages');
    }
    
    if (moderate > 5) {
      recommendations.push(`üü° MODERATE: Consider addressing ${moderate} moderate severity vulnerabilities`);
      recommendations.push('üìÖ Schedule regular security review meetings');
    }
    
    recommendations.push('‚úÖ Enable Renovate bot for automated dependency updates');
    recommendations.push('üõ°Ô∏è Consider implementing Snyk or similar security scanning tools');
    recommendations.push('üìä Set up security dashboards for continuous monitoring');
    
    if (packages.length > 10) {
      recommendations.push('üîÑ Consider dependency cleanup to reduce attack surface');
    }
    
    return recommendations;
  }

  /**
   * Save reports to various formats
   */
  private async saveReports(report: VulnerabilityReport): Promise<void> {
    const timestamp = report.timestamp.replace(/[:.]/g, '-').split('T')[0];
    
    // Save JSON report
    const jsonPath = path.join(this.outputDir, `vulnerability-report-${timestamp}.json`);
    writeFileSync(jsonPath, JSON.stringify(report, null, 2));
    
    // Save Markdown report
    const markdownPath = path.join(this.outputDir, `vulnerability-report-${timestamp}.md`);
    const markdownContent = this.generateMarkdownReport(report);
    writeFileSync(markdownPath, markdownContent);
    
    // Save latest report (for CI/CD)
    const latestJsonPath = path.join(this.outputDir, 'latest-vulnerability-report.json');
    writeFileSync(latestJsonPath, JSON.stringify(report, null, 2));
    
    console.log(`üìÅ Reports saved to ${this.outputDir}`);
  }

  /**
   * Generate Markdown report
   */
  private generateMarkdownReport(report: VulnerabilityReport): string {
    const { timestamp, totalVulnerabilities, criticalCount, highCount, moderateCount, lowCount, riskScore, complianceStatus, recommendations, affectedPackages } = report;
    
    return `# Vulnerability Assessment Report

**Generated:** ${new Date(timestamp).toLocaleString()}  
**Status:** ${complianceStatus}  
**Risk Score:** ${riskScore}/100

## Summary

| Severity | Count |
|----------|-------|
| Critical | ${criticalCount} |
| High | ${highCount} |
| Moderate | ${moderateCount} |
| Low | ${lowCount} |
| **Total** | **${totalVulnerabilities}** |

## Risk Assessment

- **Risk Score:** ${riskScore}/100
- **Compliance Status:** ${complianceStatus}
- **Affected Packages:** ${affectedPackages.length}

## Recommendations

${recommendations.map(rec => `- ${rec}`).join('\n')}

## Affected Packages

${affectedPackages.length > 0 ? affectedPackages.map(pkg => `- \`${pkg}\``).join('\n') : '_No affected packages found_'}

## Next Steps

1. Address critical and high severity vulnerabilities immediately
2. Update dependencies using \`npm audit fix\` or manual updates
3. Review and merge Renovate PRs for security updates
4. Schedule regular security assessments
5. Consider implementing additional security tools

---

_Report generated by DCT Micro-Apps Vulnerability Scanner_
`;
  }

  /**
   * Update security dashboard
   */
  private async updateSecurityDashboard(report: VulnerabilityReport): Promise<void> {
    const dashboardPath = path.join(this.projectRoot, 'docs', 'security', 'dashboard.json');
    
    let dashboard: any = {};
    
    if (existsSync(dashboardPath)) {
      try {
        dashboard = JSON.parse(readFileSync(dashboardPath, 'utf8'));
      } catch {
        dashboard = {};
      }
    }
    
    dashboard.lastScan = report.timestamp;
    dashboard.currentRiskScore = report.riskScore;
    dashboard.complianceStatus = report.complianceStatus;
    dashboard.vulnerabilitySummary = {
      critical: report.criticalCount,
      high: report.highCount,
      moderate: report.moderateCount,
      low: report.lowCount,
      total: report.totalVulnerabilities
    };
    
    // Track history
    if (!dashboard.history) {
      dashboard.history = [];
    }
    
    dashboard.history.push({
      timestamp: report.timestamp,
      riskScore: report.riskScore,
      totalVulnerabilities: report.totalVulnerabilities,
      complianceStatus: report.complianceStatus
    });
    
    // Keep only last 30 entries
    if (dashboard.history.length > 30) {
      dashboard.history = dashboard.history.slice(-30);
    }
    
    writeFileSync(dashboardPath, JSON.stringify(dashboard, null, 2));
    console.log('üìä Security dashboard updated');
  }

  /**
   * Generate security badge/status
   */
  generateSecurityBadge(complianceStatus: string): string {
    switch (complianceStatus) {
      case 'PASS':
        return '![Security Status](https://img.shields.io/badge/security-passing-green)';
      case 'WARN':
        return '![Security Status](https://img.shields.io/badge/security-warning-yellow)';
      case 'FAIL':
        return '![Security Status](https://img.shields.io/badge/security-failing-red)';
      default:
        return '![Security Status](https://img.shields.io/badge/security-unknown-gray)';
    }
  }
}

/**
 * CLI Interface
 */
async function main() {
  const scanner = new VulnerabilityScanner();
  
  try {
    console.log('üõ°Ô∏è DCT Micro-Apps Vulnerability Scanner');
    console.log('=====================================');
    
    const report = await scanner.runAssessment();
    
    console.log('\nüìä Assessment Complete');
    console.log(`Status: ${report.complianceStatus}`);
    console.log(`Risk Score: ${report.riskScore}/100`);
    console.log(`Total Vulnerabilities: ${report.totalVulnerabilities}`);
    console.log(`Critical: ${report.criticalCount}, High: ${report.highCount}, Moderate: ${report.moderateCount}, Low: ${report.lowCount}`);
    
    if (report.complianceStatus === 'FAIL') {
      console.log('\n‚ùå Security compliance check failed!');
      process.exit(1);
    } else if (report.complianceStatus === 'WARN') {
      console.log('\n‚ö†Ô∏è Security warnings detected - review recommended');
      process.exit(0);
    } else {
      console.log('\n‚úÖ Security compliance check passed');
      process.exit(0);
    }
    
  } catch (error) {
    console.error('‚ùå Vulnerability assessment failed:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

export { VulnerabilityScanner };
export type { VulnerabilityReport, PackageVulnerability };